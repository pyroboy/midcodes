[
  {
    "name": "ENUM: app_permission",
    "definition": "CREATE TYPE app_permission AS ENUM ('properties.create', 'properties.read', 'properties.update', 'properties.delete', 'floors.create', 'floors.read', 'floors.update', 'floors.delete', 'rental_units.create', 'rental_units.read', 'rental_units.update', 'rental_units.delete', 'maintenance.create', 'maintenance.read', 'maintenance.update', 'maintenance.delete', 'expenses.create', 'expenses.read', 'expenses.update', 'expenses.delete', 'tenants.create', 'tenants.read', 'tenants.update', 'tenants.delete', 'leases.create', 'leases.read', 'leases.update', 'leases.delete', 'billings.create', 'billings.read', 'billings.update', 'billings.delete', 'payments.create', 'payments.read', 'payments.update', 'payments.delete', 'payment_schedules.manage', 'payment_schedules.read', 'penalties.configure', 'meters.create', 'meters.read', 'meters.update', 'meters.delete', 'readings.create', 'readings.read', 'readings.update', 'readings.delete', 'events.create', 'events.read', 'events.update', 'events.delete', 'attendees.create', 'attendees.read', 'attendees.update', 'attendees.delete', 'attendees.check_qr', 'templates.create', 'templates.read', 'templates.update', 'templates.delete', 'idcards.create', 'idcards.read', 'idcards.update', 'idcards.delete', 'organizations.create', 'organizations.read', 'organizations.update', 'organizations.delete', 'profiles.read', 'profiles.update', 'bookings.read', 'bookings.update', 'bookings.delete');"
  },
  {
    "name": "ENUM: app_role",
    "definition": "CREATE TYPE app_role AS ENUM ('super_admin', 'org_admin', 'user', 'event_admin', 'event_qr_checker', 'property_admin', 'property_user', 'id_gen_admin', 'id_gen_user');"
  },
  {
    "name": "ENUM: billing_type",
    "definition": "CREATE TYPE billing_type AS ENUM ('RENT', 'UTILITY', 'PENALTY', 'MAINTENANCE', 'SERVICE', 'SECURITY_DEPOST');"
  },
  {
    "name": "ENUM: expense_status",
    "definition": "CREATE TYPE expense_status AS ENUM ('PENDING', 'APPROVED', 'REJECTED');"
  },
  {
    "name": "ENUM: expense_type",
    "definition": "CREATE TYPE expense_type AS ENUM ('OPERATIONAL', 'CAPITAL');"
  },
  {
    "name": "ENUM: floor_status",
    "definition": "CREATE TYPE floor_status AS ENUM ('ACTIVE', 'INACTIVE', 'MAINTENANCE');"
  },
  {
    "name": "ENUM: lease_status",
    "definition": "CREATE TYPE lease_status AS ENUM ('ACTIVE', 'INACTIVE', 'EXPIRED', 'TERMINATED', 'PENDING');"
  },
  {
    "name": "ENUM: lease_type",
    "definition": "CREATE TYPE lease_type AS ENUM ('BEDSPACER', 'PRIVATEROOM');"
  },
  {
    "name": "ENUM: location_status",
    "definition": "CREATE TYPE location_status AS ENUM ('VACANT', 'OCCUPIED', 'RESERVED');"
  },
  {
    "name": "ENUM: maintenance_status",
    "definition": "CREATE TYPE maintenance_status AS ENUM ('PENDING', 'IN_PROGRESS', 'COMPLETED');"
  },
  {
    "name": "ENUM: meter_location_type",
    "definition": "CREATE TYPE meter_location_type AS ENUM ('PROPERTY', 'FLOOR', 'RENTAL_UNIT');"
  },
  {
    "name": "ENUM: meter_status",
    "definition": "CREATE TYPE meter_status AS ENUM ('ACTIVE', 'INACTIVE', 'MAINTENANCE');"
  },
  {
    "name": "ENUM: payment_frequency",
    "definition": "CREATE TYPE payment_frequency AS ENUM ('MONTHLY', 'QUARTERLY', 'ANNUAL', 'CUSTOM', 'ONE_TIME');"
  },
  {
    "name": "ENUM: payment_method",
    "definition": "CREATE TYPE payment_method AS ENUM ('CASH', 'BANK', 'GCASH', 'OTHER');"
  },
  {
    "name": "ENUM: payment_status",
    "definition": "CREATE TYPE payment_status AS ENUM ('PENDING', 'PARTIAL', 'PAID', 'OVERDUE', 'PENALIZED');"
  },
  {
    "name": "ENUM: property_status",
    "definition": "CREATE TYPE property_status AS ENUM ('ACTIVE', 'INACTIVE', 'MAINTENANCE');"
  },
  {
    "name": "ENUM: tenant_status",
    "definition": "CREATE TYPE tenant_status AS ENUM ('ACTIVE', 'INACTIVE', 'PENDING', 'BLACKLISTED');"
  },
  {
    "name": "ENUM: unit_type",
    "definition": "CREATE TYPE unit_type AS ENUM ('BEDSPACER', 'PRIVATE_ROOM');"
  },
  {
    "name": "ENUM: user_role",
    "definition": "CREATE TYPE user_role AS ENUM ('super_admin', 'org_admin', 'user', 'event_admin', 'event_qr_checker', 'property_admin', 'property_manager', 'property_accountant', 'property_maintenance', 'property_utility', 'property_frontdesk', 'property_tenant', 'property_guest', 'id_gen_admin', 'id_gen_user');"
  },
  {
    "name": "ENUM: utility_type",
    "definition": "CREATE TYPE utility_type AS ENUM ('ELECTRICITY', 'WATER', 'INTERNET');"
  },
  {
    "name": "FUNCTION: archive_expired_attendees",
    "definition": "CREATE FUNCTION archive_expired_attendees(p_attendee_ids uuid[])\\nRETURNS TABLE(success boolean, message text, updated_count integer)\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.archive_expired_attendees(p_attendee_ids uuid[])\n RETURNS TABLE(success boolean, message text, updated_count integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n    v_updated_count integer;\n    v_ticket_info record;\n    v_event_id uuid;\n    v_ticket_type text;\n    v_ticket_index integer;\n    v_ticketing_data jsonb[];\nbegin\n    -- First, gather information about the tickets that need to be restored\n    create temp table tickets_to_restore as\n    select \n        a.id as attendee_id,\n        a.event_id,\n        a.ticket_info->>'type' as ticket_type\n    from attendees a\n    where \n        a.id = any(p_attendee_ids)\n        and a.attendance_status != 'archived'  -- Only process non-archived entries\n        and a.is_paid = false;                -- Only process unpaid entries\n\n    -- Update attendees to archived status\n    with updated_rows as (\n        update attendees\n        set \n            attendance_status = 'archived',\n            updated_at = now()\n        where \n            id = any(p_attendee_ids)\n            and attendance_status != 'archived'  -- Only update non-archived entries\n        returning id\n    )\n    select count(*) into v_updated_count\n    from updated_rows;\n\n    -- Process each ticket that needs to be restored\n    for v_ticket_info in select * from tickets_to_restore\n    loop\n        -- Get the event's current ticketing data\n        select e.ticketing_data\n        into v_ticketing_data\n        from events e\n        where e.id = v_ticket_info.event_id\n        for update;  -- Lock the row for update\n\n        -- Find the ticket index\n        select array_position(v_ticketing_data, ticket) - 1, ticket::jsonb\n        into v_ticket_index\n        from unnest(v_ticketing_data) ticket\n        where (ticket::jsonb)->>'type' = v_ticket_info.ticket_type\n        limit 1;\n\n        if v_ticket_index is not null then\n            -- Update the available count for this ticket type\n            update events\n            set \n                ticketing_data = array_replace(\n                    ticketing_data,\n                    ticketing_data[v_ticket_index + 1],\n                    jsonb_set(\n                        ticketing_data[v_ticket_index + 1]::jsonb,\n                        '{available}',\n                        to_jsonb(\n                            (ticketing_data[v_ticket_index + 1]::jsonb->>'available')::int + 1\n                        )\n                    )::jsonb\n                ),\n                updated_at = now()\n            where id = v_ticket_info.event_id;\n        end if;\n    end loop;\n\n    -- Clean up temporary table\n    drop table tickets_to_restore;\n\n    -- Return the result\n    return query\n    select \n        true as success,\n        format('Successfully archived %s attendees and restored their tickets', v_updated_count) as message,\n        v_updated_count as updated_count;\n\n    -- Handle any exceptions\n    exception when others then\n        -- Clean up temporary table if it exists\n        drop table if exists tickets_to_restore;\n        \n        -- Re-raise the exception\n        raise exception 'Error in archive_expired_attendees: %', SQLERRM;\nend;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: authorize",
    "definition": "CREATE FUNCTION authorize(requested_permission app_permission)\\nRETURNS boolean\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.authorize(requested_permission app_permission)\n RETURNS boolean\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  bind_permissions int;\n  user_roles public.app_role[];\n  raw_jwt_roles text;\n  debug_msg text;\nbegin\n  -- Get raw JWT roles claim and log it\n  raw_jwt_roles := auth.jwt() ->> 'user_roles';\n  raise notice 'Raw JWT user_roles claim: %', coalesce(raw_jwt_roles, 'NULL');\n\n  -- Parse JSON array of roles instead of comma-separated string\n  select array(\n    select trim(both '\"' from jsonb_array_elements_text(raw_jwt_roles::jsonb))::public.app_role\n  ) into user_roles;\n\n  -- Log parsed user roles\n  if user_roles is null then\n    raise notice 'Parsed user_roles array is NULL';\n  else\n    raise notice 'Parsed user_roles array: %', array_to_string(user_roles, ', ');\n    raise notice 'Number of roles found: %', array_length(user_roles, 1);\n  end if;\n\n  -- If no roles found, return false\n  if user_roles is null or array_length(user_roles, 1) = 0 then\n    raise notice 'No valid roles found, returning false';\n    return false;\n  end if;\n\n  -- Check if any of the user's roles have the requested permission\n  select count(*)\n  into bind_permissions\n  from public.role_permissions\n  where role_permissions.permission = requested_permission\n    and role_permissions.role = any(user_roles);\n\n  -- Log the result\n  raise notice 'Number of matching permissions found: %', bind_permissions;\n\n  return bind_permissions > 0;\nexception \n  when others then\n    -- Enhanced error logging\n    raise warning 'Error in authorize function: %', SQLERRM;\n    raise warning 'Error details: %', SQLSTATE;\n    raise warning 'Context: %', SQLERRM;\n    -- Log the values that were being processed when the error occurred\n    raise warning 'Debug context - Requested permission: %, Raw JWT: %',\n      requested_permission,\n      coalesce(raw_jwt_roles, 'NULL');\n    return false;\nend;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: begin_transaction",
    "definition": "CREATE FUNCTION begin_transaction()\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.begin_transaction()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    txid text;\nBEGIN\n    txid := txid_current()::text;\n    PERFORM set_config('app.current_transaction', txid, true);\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: calculate_penalty",
    "definition": "CREATE FUNCTION calculate_penalty(p_billing_id integer)\\nRETURNS numeric\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.calculate_penalty(p_billing_id integer)\n RETURNS numeric\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_billing record;\n    v_config record;\n    v_days_late INTEGER;\n    v_penalty_amount DECIMAL;\n    v_compound_cycles INTEGER;\nBEGIN\n    SELECT * INTO v_billing \n    FROM billings \n    WHERE id = p_billing_id;\n\n    SELECT * INTO v_config \n    FROM penalty_configs \n    WHERE type = v_billing.type;\n\n    IF v_billing.status = 'PAID' OR v_config IS NULL THEN\n        RETURN 0;\n    END IF;\n\n    v_days_late := EXTRACT(DAY FROM NOW() - v_billing.due_date) - v_config.grace_period;\n\n    IF v_days_late <= 0 THEN\n        RETURN 0;\n    END IF;\n\n    v_penalty_amount := v_billing.balance * (v_config.penalty_percentage / 100);\n\n    IF v_config.compound_period IS NOT NULL AND v_days_late > v_config.compound_period THEN\n        v_compound_cycles := FLOOR(v_days_late::DECIMAL / v_config.compound_period::DECIMAL);\n        v_penalty_amount := v_billing.balance * (POWER(1 + v_config.penalty_percentage / 100, v_compound_cycles) - 1);\n    END IF;\n\n    IF v_config.max_penalty_percentage IS NOT NULL THEN\n        v_penalty_amount := LEAST(\n            v_penalty_amount, \n            v_billing.balance * (v_config.max_penalty_percentage / 100)\n        );\n    END IF;\n\n    RETURN ROUND(v_penalty_amount, 2);\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: check_registration_status",
    "definition": "CREATE FUNCTION check_registration_status(p_reference_code text)\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.check_registration_status(p_reference_code text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_attendee attendees%ROWTYPE;  -- Use %ROWTYPE to define the record type\n    v_event events%ROWTYPE;         -- Use %ROWTYPE to define the record type\n    v_time_remaining INTEGER;\nBEGIN\n    -- Get attendee details\n    SELECT *\n    INTO v_attendee\n    FROM attendees\n    WHERE reference_code_url = p_reference_code;\n\n    IF NOT FOUND THEN\n        RETURN jsonb_build_object(\n            'status', 'not_found',\n            'message', 'Registration not found'\n        );\n    END IF;\n\n    -- Get event details\n    SELECT payment_timeout_minutes, event_name\n    INTO v_event\n    FROM events\n    WHERE id = v_attendee.event_id;\n\n    -- Calculate time remaining for payment\n    IF v_attendee.attendance_status = 'paymentPending' THEN\n        SELECT \n            EXTRACT(EPOCH FROM (\n                v_attendee.created_at + \n                (COALESCE(v_event.payment_timeout_minutes, 15) || ' minutes')::interval - \n                NOW()\n            ))::INTEGER / 60\n        INTO v_time_remaining;\n    END IF;\n\n    RETURN jsonb_build_object(\n        'status', v_attendee.attendance_status,\n        'is_paid', v_attendee.is_paid,\n        'time_remaining_minutes', GREATEST(v_time_remaining, 0),\n        'reference_code', v_attendee.reference_code_url,\n        'event_name', v_event.event_name\n    );\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: check_template_org_id",
    "definition": "CREATE FUNCTION check_template_org_id()\\nRETURNS trigger\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.check_template_org_id()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF EXISTS (\r\n    SELECT 1 FROM profiles \r\n    WHERE id = auth.uid() \r\n    AND role != 'super_admin'::user_role \r\n    AND NEW.org_id IS NULL\r\n  ) THEN\r\n    RAISE EXCEPTION 'org_id is required for non-super_admin users';\r\n  END IF;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: cleanup_expired_registrations",
    "definition": "CREATE FUNCTION cleanup_expired_registrations()\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.cleanup_expired_registrations()\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    processed_count int;\n    result_json jsonb;\nBEGIN\n    WITH expired_registrations AS (\n        SELECT a.id, a.event_id, a.ticket_info->>'type' as ticket_type\n        FROM attendees a\n        JOIN events e ON e.id = a.event_id\n        WHERE a.attendance_status = 'paymentPending'\n        AND NOT a.is_paid\n        AND a.created_at < NOW() - (COALESCE(e.payment_timeout_minutes, 15) || ' minutes')::interval\n        LIMIT 1000\n        FOR UPDATE SKIP LOCKED\n    )\n    UPDATE attendees a\n    SET \n        attendance_status = 'archived',\n        updated_at = NOW()\n    FROM expired_registrations er\n    WHERE a.id = er.id\n    RETURNING (SELECT COUNT(*)) INTO processed_count;\n\n    IF processed_count > 0 THEN\n        WITH expired_tickets AS (\n            SELECT \n                event_id,\n                ticket_type,\n                COUNT(*) as expired_count\n            FROM expired_registrations\n            GROUP BY event_id, ticket_type\n        )\n        UPDATE events e\n        SET ticketing_data = (\n            SELECT array_agg(\n                CASE \n                    WHEN value->>'type' = et.ticket_type THEN\n                        jsonb_set(\n                            value,\n                            '{available}',\n                            to_jsonb((value->>'available')::int + et.expired_count)\n                        )\n                    ELSE value\n                END\n            )\n            FROM unnest(e.ticketing_data) value\n            CROSS JOIN expired_tickets et\n            WHERE et.event_id = e.id\n            GROUP BY et.event_id\n        )\n        FROM expired_tickets et\n        WHERE e.id = et.event_id;\n        \n        result_json := jsonb_build_object(\n            'success', true,\n            'processed_count', processed_count,\n            'message', processed_count || ' registrations archived'\n        );\n    ELSE\n        result_json := jsonb_build_object(\n            'success', true,\n            'processed_count', 0,\n            'message', 'No registrations to archive'\n        );\n    END IF;\n\n    RETURN result_json;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: commit_transaction",
    "definition": "CREATE FUNCTION commit_transaction()\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.commit_transaction()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    txid text;\nBEGIN\n    txid := current_setting('app.current_transaction', true);\n    IF txid IS NOT NULL THEN\n        PERFORM set_config('app.current_transaction', NULL, true);\n    END IF;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: confirm_attendee_payment",
    "definition": "CREATE FUNCTION confirm_attendee_payment(p_attendee_id uuid)\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.confirm_attendee_payment(p_attendee_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_event events;\n    v_attendee attendees;\n    v_ticket_index INTEGER;\n    v_time_expired BOOLEAN;\n    v_ticket_data jsonb;\nBEGIN\n    SELECT * INTO v_attendee\n    FROM attendees\n    WHERE id = p_attendee_id\n    AND attendance_status = 'paymentPending'\n    AND NOT is_paid\n    FOR UPDATE;\n\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Invalid attendee or payment already processed';\n    END IF;\n\n    SELECT * INTO v_event\n    FROM events\n    WHERE id = v_attendee.event_id\n    FOR UPDATE;\n\n    SELECT (v_attendee.created_at + (COALESCE(v_event.payment_timeout_minutes, 15) || ' minutes')::interval) < NOW()\n    INTO v_time_expired;\n\n    IF v_time_expired THEN\n        UPDATE attendees\n        SET \n            attendance_status = 'expired',\n            updated_at = now()\n        WHERE id = p_attendee_id;\n\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Payment window has expired',\n            'status', 'expired'\n        );\n    END IF;\n\n    SELECT array_position(v_event.ticketing_data, ticket) - 1, ticket::jsonb\n    INTO v_ticket_index, v_ticket_data\n    FROM unnest(v_event.ticketing_data) ticket\n    WHERE (ticket::jsonb)->>'type' = v_attendee.ticket_info->>'type'\n    LIMIT 1;\n\n    IF v_ticket_index IS NULL THEN\n        RAISE EXCEPTION 'Ticket type not found';\n    END IF;\n\n    UPDATE events\n    SET \n        ticketing_data = array_replace(\n            ticketing_data,\n            ticketing_data[v_ticket_index + 1],\n            jsonb_set(\n                ticketing_data[v_ticket_index + 1]::jsonb,\n                '{available}',\n                to_jsonb((ticketing_data[v_ticket_index + 1]::jsonb->>'available')::int - 1)\n            )::jsonb\n        ),\n        updated_at = now()\n    WHERE id = v_attendee.event_id;\n\n    UPDATE attendees\n    SET \n        attendance_status = 'registered',\n        is_paid = true,\n        updated_at = now()\n    WHERE id = p_attendee_id;\n\n    RETURN jsonb_build_object(\n        'success', true,\n        'status', 'registered'\n    );\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: confirm_attendee_payment",
    "definition": "CREATE FUNCTION confirm_attendee_payment(p_attendee_id uuid, p_received_by uuid)\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.confirm_attendee_payment(p_attendee_id uuid, p_received_by uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_event events;\n    v_attendee attendees;\n    v_ticket_index INTEGER;\n    v_time_expired BOOLEAN;\n    v_ticket_data jsonb;\nBEGIN\n    -- Validate received_by parameter\n    IF p_received_by IS NULL THEN\n        RAISE EXCEPTION 'received_by parameter is required';\n    END IF;\n\n    -- Get and lock attendee record - keeping existing logic\n SELECT * INTO v_attendee\nFROM attendees\nWHERE id = p_attendee_id\nAND attendance_status = 'paymentPending'\nAND NOT is_paid\nFOR UPDATE;\n\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Invalid attendee or payment already processed';\n    END IF;\n\n    -- Get and lock event record - keeping existing logic\n    SELECT * INTO v_event\n    FROM events\n    WHERE id = v_attendee.event_id\n    FOR UPDATE;\n\n    -- Check expiration - keeping existing logic\n    SELECT (v_attendee.created_at + (COALESCE(v_event.payment_timeout_minutes, 15) || ' minutes')::interval) < NOW()\n    INTO v_time_expired;\n\n    IF v_time_expired THEN\n        UPDATE attendees\n        SET \n            attendance_status = 'expired',\n            updated_at = now()\n        WHERE id = p_attendee_id;\n\n        RETURN jsonb_build_object(\n            'success', false,\n            'message', 'Payment window has expired',\n            'status', 'expired'\n        );\n    END IF;\n\n    -- Get ticket data - keeping existing logic\n    SELECT array_position(v_event.ticketing_data, ticket) - 1, ticket::jsonb\n    INTO v_ticket_index, v_ticket_data\n    FROM unnest(v_event.ticketing_data) ticket\n    WHERE (ticket::jsonb)->>'type' = v_attendee.ticket_info->>'type'\n    LIMIT 1;\n\n    IF v_ticket_index IS NULL THEN\n        RAISE EXCEPTION 'Ticket type not found';\n    END IF;\n\n    -- Update event ticket count - keeping existing logic\n    UPDATE events\n    SET \n        ticketing_data = array_replace(\n            ticketing_data,\n            ticketing_data[v_ticket_index + 1],\n            jsonb_set(\n                ticketing_data[v_ticket_index + 1]::jsonb,\n                '{available}',\n                to_jsonb((ticketing_data[v_ticket_index + 1]::jsonb->>'available')::int - 1)\n            )::jsonb\n        ),\n        updated_at = now()\n    WHERE id = v_attendee.event_id;\n\n    -- Update attendee status - now including received_by\n    UPDATE attendees\n    SET \n        attendance_status = 'registered',\n        is_paid = true,\n        received_by = p_received_by,  -- Added received_by tracking\n        updated_at = now()\n    WHERE id = p_attendee_id;\n\n    -- Return success response with additional received_by information\n    RETURN jsonb_build_object(\n        'success', true,\n        'status', 'registered',\n        'received_by', p_received_by\n    );\n\nEXCEPTION\n    WHEN OTHERS THEN\n        -- Added error handling to include more context\n        RAISE EXCEPTION 'Payment confirmation failed for attendee ID % with receiver ID %: %', \n            p_attendee_id, p_received_by, SQLERRM;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: create_payment",
    "definition": "CREATE FUNCTION create_payment(p_amount numeric, p_method payment_method, p_billing_ids integer[], p_paid_by text, p_paid_at timestamp with time zone, p_reference_number text DEFAULT NULL::text, p_notes text DEFAULT NULL::text, p_created_by uuid DEFAULT NULL::uuid)\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.create_payment(p_amount numeric, p_method payment_method, p_billing_ids integer[], p_paid_by text, p_paid_at timestamp with time zone, p_reference_number text DEFAULT NULL::text, p_notes text DEFAULT NULL::text, p_created_by uuid DEFAULT NULL::uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_payment_id       int;\r\n    v_remaining        numeric := p_amount;\r\n    v_billing_id       int;          -- << declared\r\n    v_billing          record;\r\n    v_amount_to_apply  numeric;\r\nBEGIN\r\n    -- 1. create the payment row\r\n    INSERT INTO payments(amount, method, reference_number,\r\n                         paid_by, paid_at, notes, created_by, billing_ids)\r\n    VALUES (p_amount, p_method, p_reference_number,\r\n            p_paid_by, p_paid_at, p_notes, p_created_by, p_billing_ids)\r\n    RETURNING id INTO v_payment_id;\r\n\r\n    -- 2. allocate to billings\r\n    FOREACH v_billing_id IN ARRAY p_billing_ids LOOP\r\n        EXIT WHEN v_remaining <= 0;\r\n\r\n        SELECT * INTO v_billing\r\n        FROM billings\r\n        WHERE id = v_billing_id\r\n        FOR UPDATE;\r\n\r\n        v_amount_to_apply := LEAST(\r\n            v_remaining,\r\n            v_billing.amount + COALESCE(v_billing.penalty_amount, 0) - v_billing.paid_amount\r\n        );\r\n\r\n        IF v_amount_to_apply > 0 THEN\r\n            UPDATE billings\r\n            SET paid_amount  = paid_amount + v_amount_to_apply,\r\n                balance      = (amount + COALESCE(penalty_amount, 0))\r\n                               - (paid_amount + v_amount_to_apply),\r\n                status       = CASE\r\n                                   WHEN paid_amount + v_amount_to_apply\r\n                                        >= amount + COALESCE(penalty_amount, 0)\r\n                                   THEN 'PAID'::public.payment_status\r\n                                   ELSE 'PARTIAL'::public.payment_status\r\n                               END,\r\n                updated_at   = NOW()\r\n            WHERE id = v_billing_id;\r\n\r\n            INSERT INTO payment_allocations(payment_id, billing_id, amount)\r\n            VALUES (v_payment_id, v_billing_id, v_amount_to_apply);\r\n\r\n            v_remaining := v_remaining - v_amount_to_apply;\r\n        END IF;\r\n    END LOOP;\r\n\r\n    RETURN to_jsonb((SELECT p FROM payments p WHERE p.id = v_payment_id));\r\nEND;\r\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: custom_access_token_hook",
    "definition": "CREATE FUNCTION custom_access_token_hook(event jsonb)\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\nAS $function$\r\ndeclare\r\n    claims jsonb;\r\n    user_roles text[];\r\n    user_org_id uuid;\r\nbegin\r\n    -- Start logging\r\n    raise log 'HOOK START: Processing event for user: %', (event->>'user_id');\r\n    \r\n    -- Extract claims from event\r\n    claims := event->'claims';\r\n    IF claims IS NULL THEN\r\n        raise warning 'Claims is null in event: %', event;\r\n        return event;\r\n    END IF;\r\n    \r\n    BEGIN  -- Inner exception block for roles query\r\n        select array_agg(role::text)\r\n        into user_roles \r\n        from public.user_roles \r\n        where user_id = (event->>'user_id')::uuid;\r\n        raise log 'Roles found: %', user_roles;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        raise warning 'Error fetching roles: % (State: %)', SQLERRM, SQLSTATE;\r\n    END;\r\n\r\n\r\n\r\n    -- Set the claims with error handling\r\n    BEGIN\r\n        if user_roles is not null then\r\n            claims := jsonb_set(claims, '{user_roles}', to_jsonb(user_roles));\r\n        else\r\n            claims := jsonb_set(claims, '{user_roles}', '[]');\r\n        end if;\r\n\r\n        \r\n        raise log 'Claims set successfully: %', claims;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        raise warning 'Error setting claims: % (State: %)', SQLERRM, SQLSTATE;\r\n        return event;\r\n    END;\r\n\r\n    -- Final return with error handling\r\n    BEGIN\r\n        return jsonb_set(event, '{claims}', claims);\r\n    EXCEPTION WHEN OTHERS THEN\r\n        raise warning 'Error in final jsonb_set: % (State: %)', SQLERRM, SQLSTATE;\r\n        return event;\r\n    END;\r\n\r\nexception \r\n    when others then\r\n        raise warning 'MAIN ERROR in custom_access_token_hook: % (State: %) - Event: %', \r\n            SQLERRM, \r\n            SQLSTATE,\r\n            event;\r\n        return event;\r\nend;\r\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: delete_lease_and_dependents",
    "definition": "CREATE FUNCTION delete_lease_and_dependents(p_lease_id integer)\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.delete_lease_and_dependents(p_lease_id integer)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n  -- Delete associated lease_tenants records\r\n  DELETE FROM public.lease_tenants WHERE lease_id = p_lease_id;\r\n\r\n  -- Delete associated billings\r\n  DELETE FROM public.billings WHERE lease_id = p_lease_id;\r\n\r\n  -- Finally, delete the lease itself\r\n  DELETE FROM public.leases WHERE id = p_lease_id;\r\nEND;\r\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: delete_property",
    "definition": "CREATE FUNCTION delete_property(property_id integer)\\nRETURNS boolean\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.delete_property(property_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    SET search_path = '';\n    -- The cascade will handle all dependent records\n    DELETE FROM properties WHERE id = property_id;\n    RETURN FOUND;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: delete_property_v2",
    "definition": "CREATE FUNCTION delete_property_v2(property_id integer)\\nRETURNS boolean\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.delete_property_v2(property_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Delete billings\n    DELETE FROM billings\n    WHERE lease_id IN (\n        SELECT l.id FROM leases l\n        JOIN rental_unit ru ON ru.id = l.rental_unit_id\n        WHERE ru.property_id = property_id\n    );\n\n    -- Delete payment schedules\n    DELETE FROM payment_schedules\n    WHERE lease_id IN (\n        SELECT l.id FROM leases l\n        JOIN rental_unit ru ON ru.id = l.rental_unit_id\n        WHERE ru.property_id = property_id\n    );\n\n    -- Delete lease tenants\n    DELETE FROM lease_tenants\n    WHERE lease_id IN (\n        SELECT l.id FROM leases l\n        JOIN rental_unit ru ON ru.id = l.rental_unit_id\n        WHERE ru.property_id = property_id\n    );\n\n    -- Delete leases\n    DELETE FROM leases\n    WHERE rental_unit_id IN (\n        SELECT id FROM rental_unit WHERE property_id = property_id\n    );\n\n    -- Delete rental units\n    DELETE FROM rental_unit WHERE property_id = property_id;\n\n    -- Finally delete the property\n    DELETE FROM properties WHERE id = property_id;\n\n    RETURN TRUE; -- Return true if deletion was successful\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: delete_template_cascade",
    "definition": "CREATE FUNCTION delete_template_cascade()\\nRETURNS trigger\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.delete_template_cascade()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Set template_id to NULL in idcards\n  UPDATE idcards SET template_id = NULL WHERE template_id = OLD.id;\n  \n  RETURN OLD;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: delete_trigger_and_function",
    "definition": "CREATE FUNCTION delete_trigger_and_function()\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.delete_trigger_and_function()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Drop the trigger if it exists\n    IF EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'update_lease_status_on_change') THEN\n        EXECUTE 'DROP TRIGGER update_lease_status_on_change ON leases;';\n    END IF;\n\n    -- Drop the function if it exists\n    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_lease_status') THEN\n        EXECUTE 'DROP FUNCTION update_lease_status;';\n    END IF;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: drop_all_rls_policies",
    "definition": "CREATE FUNCTION drop_all_rls_policies()\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.drop_all_rls_policies()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    table_name text;\n    policy_name text;\nBEGIN\n    -- Drop policies for Property Management Module\n    FOR table_name, policy_name IN \n        SELECT schemaname || '.' || tablename, policyname\n        FROM pg_policies \n        WHERE schemaname = 'public' \n        AND tablename IN (\n            'properties',\n            'floors',\n            'rental_unit',\n            'maintenance',\n            'expenses'\n        )\n    LOOP\n        EXECUTE format('DROP POLICY IF EXISTS %I ON %s', policy_name, table_name);\n    END LOOP;\n\n    -- Drop policies for Tenancy Module\n    FOR table_name, policy_name IN \n        SELECT schemaname || '.' || tablename, policyname\n        FROM pg_policies \n        WHERE schemaname = 'public' \n        AND tablename IN (\n            'tenants',\n            'leases',\n            'lease_tenants'\n        )\n    LOOP\n        EXECUTE format('DROP POLICY IF EXISTS %I ON %s', policy_name, table_name);\n    END LOOP;\n\n    -- Drop policies for Billing Module\n    FOR table_name, policy_name IN \n        SELECT schemaname || '.' || tablename, policyname\n        FROM pg_policies \n        WHERE schemaname = 'public' \n        AND tablename IN (\n            'billings',\n            'payments',\n            'payment_schedules',\n            'penalty_configs'\n        )\n    LOOP\n        EXECUTE format('DROP POLICY IF EXISTS %I ON %s', policy_name, table_name);\n    END LOOP;\n\n    -- Drop policies for Utility Management Module\n    FOR table_name, policy_name IN \n        SELECT schemaname || '.' || tablename, policyname\n        FROM pg_policies \n        WHERE schemaname = 'public' \n        AND tablename IN (\n            'meters',\n            'readings'\n        )\n    LOOP\n        EXECUTE format('DROP POLICY IF EXISTS %I ON %s', policy_name, table_name);\n    END LOOP;\n\n    -- Disable RLS for all tables\n    FOR table_name IN \n        SELECT tablename \n        FROM pg_tables \n        WHERE schemaname = 'public' \n        AND tablename IN (\n            'properties',\n            'floors',\n            'rental_unit',\n            'maintenance',\n            'expenses',\n            'tenants',\n            'leases',\n            'lease_tenants',\n            'billings',\n            'payments',\n            'payment_schedules',\n            'penalty_configs',\n            'meters',\n            'readings'\n        )\n    LOOP\n        EXECUTE format('ALTER TABLE public.%I DISABLE ROW LEVEL SECURITY', table_name);\n    END LOOP;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: enable_all_rls_policies",
    "definition": "CREATE FUNCTION enable_all_rls_policies()\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.enable_all_rls_policies()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Property Management Module\n    ALTER TABLE public.properties ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.floors ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.rental_unit ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.maintenance ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.expenses ENABLE ROW LEVEL SECURITY;\n\n    -- Tenancy Module\n    ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.leases ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.lease_tenants ENABLE ROW LEVEL SECURITY;\n\n    -- Billing Module\n    ALTER TABLE public.billings ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.payment_schedules ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.penalty_configs ENABLE ROW LEVEL SECURITY;\n\n    -- Utility Management Module\n    ALTER TABLE public.meters ENABLE ROW LEVEL SECURITY;\n    ALTER TABLE public.readings ENABLE ROW LEVEL SECURITY;\n\n    RAISE NOTICE 'Row Level Security has been enabled for all tables';\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: get_current_context",
    "definition": "CREATE FUNCTION get_current_context()\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.get_current_context()\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  current_context jsonb;\nBEGIN\n  SELECT \n    COALESCE(\n      (\n        SELECT metadata \n        FROM role_emulation_sessions \n        WHERE user_id = auth.uid() \n        AND status = 'active' \n        AND expires_at > now()\n        ORDER BY created_at DESC \n        LIMIT 1\n      ),\n      (SELECT context FROM profiles WHERE id = auth.uid()),\n      '{}'::jsonb\n    ) INTO current_context;\n  RETURN current_context;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: get_effective_role",
    "definition": "CREATE FUNCTION get_effective_role(user_uuid uuid)\\nRETURNS user_role\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.get_effective_role(user_uuid uuid)\n RETURNS user_role\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    effective_role user_role;\nBEGIN\n    -- Check for active emulation\n    SELECT emulated_role INTO effective_role\n    FROM public.role_emulation_sessions\n    WHERE user_id = user_uuid\n        AND status = 'active'\n        AND expires_at > NOW()\n    ORDER BY created_at DESC\n    LIMIT 1;\n\n    -- If no active emulation, return original role\n    IF effective_role IS NULL THEN\n        SELECT role INTO effective_role\n        FROM public.profiles\n        WHERE id = user_uuid;\n    END IF;\n\n    RETURN effective_role;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: get_idcards_by_org",
    "definition": "CREATE FUNCTION get_idcards_by_org(org_id uuid, page_limit integer DEFAULT NULL::integer, page_offset integer DEFAULT 0)\\nRETURNS json\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.get_idcards_by_org(org_id uuid, page_limit integer DEFAULT NULL::integer, page_offset integer DEFAULT 0)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    total_count bigint;\n    limit_clause text;\n    header_metadata jsonb;\n    template_fields jsonb;\n    idcard_results json;\nBEGIN\n    -- Get total count for pagination info\n    SELECT COUNT(*)\n    INTO total_count\n    FROM idcards\n    WHERE idcards.org_id = get_idcards_by_org.org_id;\n\n    -- Set limit clause based on parameter\n    limit_clause := CASE \n        WHEN page_limit IS NULL THEN ''\n        ELSE format(' LIMIT %L OFFSET %L', page_limit, page_offset)\n    END;\n\n    -- Get unique template names and their fields\n    WITH template_info AS (\n        SELECT DISTINCT \n            t.name as template_name,\n            (\n                SELECT jsonb_agg(\n                    jsonb_build_object(\n                        'variableName', elem->>'variableName',\n                        'side', elem->>'side'\n                    )\n                    ORDER BY \n                        CASE WHEN elem->>'side' = 'front' THEN 0 ELSE 1 END,\n                        elem->>'variableName'\n                )\n                FROM jsonb_array_elements(t.template_elements) elem\n                WHERE elem->>'variableName' IS NOT NULL\n                AND elem->>'type' NOT IN ('photo', 'signature')\n            ) as variable_names\n        FROM templates t\n        WHERE t.org_id = get_idcards_by_org.org_id\n    )\n    SELECT jsonb_object_agg(template_name, variable_names)\n    INTO template_fields\n    FROM template_info;\n\n    -- Build header metadata\n    header_metadata := jsonb_build_object(\n        'organization_name', (SELECT name FROM organizations WHERE id = get_idcards_by_org.org_id),\n        'templates', template_fields,\n        'pagination', jsonb_build_object(\n            'total_records', total_count,\n            'current_offset', page_offset,\n            'limit', page_limit\n        )\n    );\n\n    -- Get idcard results\n    EXECUTE format(\n        'WITH idcard_data AS (\n            SELECT \n                json_build_object(\n                    ''idcard_id'', i.id,\n                    ''template_name'', t.name,\n                    ''front_image'', i.front_image,\n                    ''back_image'', i.back_image,\n                    ''created_at'', i.created_at,\n                    ''fields'', (\n                        SELECT jsonb_object_agg(\n                            elem->>''variableName'',\n                            jsonb_build_object(\n                                ''value'', COALESCE(\n                                    i.data->(elem->>''variableName''),\n                                    to_jsonb(elem->>''content'')\n                                ),\n                                ''side'', elem->>''side''\n                            )\n                            ORDER BY \n                                CASE WHEN elem->>''side'' = ''front'' THEN 0 ELSE 1 END,\n                                elem->>''variableName''\n                        )\n                        FROM jsonb_array_elements(t.template_elements) elem\n                        WHERE elem->>''variableName'' IS NOT NULL\n                        AND elem->>''type'' NOT IN (''photo'', ''signature'')\n                    )\n                ) as card_data\n            FROM idcards i\n            JOIN templates t ON i.template_id = t.id\n            JOIN organizations o ON i.org_id = o.id\n            WHERE i.org_id = %L\n            ORDER BY t.name, i.created_at DESC\n            %s\n        )\n        SELECT json_agg(card_data)\n        FROM idcard_data',\n        get_idcards_by_org.org_id,\n        limit_clause\n    ) INTO idcard_results;\n\n    -- Return success response\n    RETURN json_build_object(\n        'metadata', header_metadata,\n        'idcards', COALESCE(idcard_results, '[]'::json)\n    );\n\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: get_template_by_id",
    "definition": "CREATE FUNCTION get_template_by_id(p_template_id uuid, p_user_id uuid)\\nRETURNS SETOF templates\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.get_template_by_id(p_template_id uuid, p_user_id uuid)\n RETURNS SETOF templates\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nbegin\r\n  return query\r\n  select *\r\n  from templates\r\n  where id = p_template_id\r\n  and user_id = p_user_id;\r\nend;\r\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: get_tenant_monthly_balances",
    "definition": "CREATE FUNCTION get_tenant_monthly_balances(p_property_id integer, p_months_back integer)\\nRETURNS TABLE(tenant_id integer, month text, balance numeric)\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.get_tenant_monthly_balances(p_property_id integer, p_months_back integer)\n RETURNS TABLE(tenant_id integer, month text, balance numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Input validation\n  IF p_property_id IS NULL THEN\n    RAISE EXCEPTION 'Property ID cannot be null';\n  END IF;\n  \n  IF p_months_back < 0 THEN\n    RAISE EXCEPTION 'Months back must be a positive number';\n  END IF;\n\n  -- Return query with results\n  RETURN QUERY\n  SELECT\n    t.id AS tenant_id,\n    DATE_TRUNC('month', b.billing_date)::text AS month,\n    SUM(b.balance) AS balance\n  FROM billings b\n  INNER JOIN leases l ON b.lease_id = l.id\n  INNER JOIN rooms r ON l.location_id = r.id\n  INNER JOIN lease_tenants lt ON l.id = lt.lease_id\n  INNER JOIN tenants t ON lt.tenant_id = t.id\n  WHERE\n    l.status = 'ACTIVE'\n    AND r.property_id = p_property_id\n    AND b.billing_date >= DATE_TRUNC('month', CURRENT_DATE - (p_months_back || ' months')::interval)\n  GROUP BY t.id, DATE_TRUNC('month', b.billing_date)\n  ORDER BY t.id, DATE_TRUNC('month', b.billing_date);\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: get_tenant_payment_history",
    "definition": "CREATE FUNCTION get_tenant_payment_history(p_tenant_id bigint)\\nRETURNS TABLE(due_date date, amount numeric, type billing_type, status payment_status, days_overdue integer)\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.get_tenant_payment_history(p_tenant_id bigint)\n RETURNS TABLE(due_date date, amount numeric, type billing_type, status payment_status, days_overdue integer)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        ps.due_date,\n        ps.amount,\n        ps.type,\n        ps.status,\n        CASE \n            WHEN ps.status = 'PENDING' AND ps.due_date < CURRENT_DATE \n            THEN DATE_PART('day', CURRENT_DATE - ps.due_date)::INTEGER\n            ELSE 0\n        END as days_overdue\n    FROM payment_schedules ps\n    WHERE ps.tenant_id = p_tenant_id\n    ORDER BY ps.due_date DESC;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: get_user_role_type_oid",
    "definition": "CREATE FUNCTION get_user_role_type_oid()\\nRETURNS oid\\nLANGUAGE sql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.get_user_role_type_oid()\n RETURNS oid\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  SELECT oid FROM pg_type WHERE typname = 'user_role';\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: handle_new_user",
    "definition": "CREATE FUNCTION handle_new_user()\\nRETURNS trigger\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n  insert into public.profiles (id, email, role)\n  values (new.id, new.email, 'user');\n  return new;\nend;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: is_admin_level",
    "definition": "CREATE FUNCTION is_admin_level()\\nRETURNS boolean\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.is_admin_level()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM profiles\n    WHERE id = auth.uid()\n    AND role IN ('super_admin', 'property_admin', 'property_manager')\n  );\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: is_staff_level",
    "definition": "CREATE FUNCTION is_staff_level()\\nRETURNS boolean\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.is_staff_level()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM profiles\n    WHERE id = auth.uid()\n    AND role IN ('super_admin', 'property_admin', 'property_manager',\n                 'property_accountant', 'property_maintenance', \n                 'property_utility', 'property_frontdesk')\n  );\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: process_penalties",
    "definition": "CREATE FUNCTION process_penalties()\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.process_penalties()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    v_billing record;\n    v_penalty_amount DECIMAL;\nBEGIN\n    FOR v_billing IN \n        SELECT * \n        FROM billings \n        WHERE status != 'PAID' \n        AND due_date < CURRENT_DATE\n    LOOP\n        v_penalty_amount := calculate_penalty(v_billing.id);\n        \n        IF v_penalty_amount > 0 THEN\n            INSERT INTO billings (\n                lease_id,\n                type,\n                amount,\n                paid_amount,\n                balance,\n                status,\n                due_date,\n                billing_date,\n                notes\n            ) VALUES (\n                v_billing.lease_id,\n                'PENALTY',\n                v_penalty_amount,\n                0,\n                v_penalty_amount,\n                'PENDING',\n                CURRENT_DATE,\n                CURRENT_DATE,\n                'Penalty for ' || v_billing.type || ' billing #' || v_billing.id\n            );\n\n            UPDATE billings \n            SET penalty_amount = v_penalty_amount\n            WHERE id = v_billing.id;\n        END IF;\n    END LOOP;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: register_attendee",
    "definition": "CREATE FUNCTION register_attendee(p_event_id uuid, p_ticket_type text, p_basic_info jsonb, p_ticket_info jsonb, p_org_id uuid, p_qr_link text, p_reference_code text)\\nRETURNS jsonb\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.register_attendee(p_event_id uuid, p_ticket_type text, p_basic_info jsonb, p_ticket_info jsonb, p_org_id uuid, p_qr_link text, p_reference_code text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_event events;\n    v_reserved_count INTEGER;\n    v_ticket_index INTEGER;\n    v_tickets JSONB[];\nBEGIN\n    -- Lock the event row for update\n    SELECT * INTO v_event\n    FROM events\n    WHERE id = p_event_id\n    FOR UPDATE;\n\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Event not found';\n    END IF;\n\n    -- Find the ticket index\n    SELECT array_position(\n        (SELECT array_agg(value->>'type')\n         FROM unnest(v_event.ticketing_data) AS value),\n        p_ticket_type\n    ) INTO v_ticket_index;\n\n    IF v_ticket_index IS NULL THEN\n        RAISE EXCEPTION 'Ticket type not found';\n    END IF;\n\n    -- Count current reservations\n    SELECT COUNT(*) INTO v_reserved_count\n    FROM attendees\n    WHERE event_id = p_event_id\n    AND ticket_info->>'type' = p_ticket_type\n    AND attendance_status = 'paymentPending'\n    AND created_at > NOW() - (COALESCE(v_event.payment_timeout_minutes, 15) || ' minutes')::interval;\n\n    -- Check availability\n    IF (v_event.ticketing_data[v_ticket_index]->>'available')::int <= v_reserved_count THEN\n        RAISE EXCEPTION 'No tickets available';\n    END IF;\n\n    -- Insert attendee\n    INSERT INTO attendees (\n        basic_info,\n        event_id,\n        ticket_info,\n        org_id,\n        qr_link,\n        reference_code_url,\n        attendance_status,\n        is_paid\n    ) VALUES (\n        p_basic_info,\n        p_event_id,\n        p_ticket_info,\n        p_org_id,\n        p_qr_link,\n        p_reference_code,\n        'paymentPending',\n        false\n    );\n\n    -- Create updated tickets array\n    SELECT array_agg(\n        CASE \n            WHEN ordinality = v_ticket_index THEN\n                jsonb_set(\n                    ticket,\n                    '{available}',\n                    to_jsonb((ticket->>'available')::int - 1)\n                )\n            ELSE ticket\n        END\n    )\n    INTO v_tickets\n    FROM unnest(v_event.ticketing_data) WITH ORDINALITY AS t(ticket, ordinality);\n\n    -- Update event\n    UPDATE events \n    SET \n        ticketing_data = v_tickets,\n        updated_at = now()\n    WHERE id = p_event_id;\n\n    RETURN jsonb_build_object(\n        'success', true,\n        'payment_timeout_minutes', COALESCE(v_event.payment_timeout_minutes, 15)\n    );\nEXCEPTION WHEN OTHERS THEN\n    RAISE NOTICE 'Error in register_attendee: %', SQLERRM;\n    RAISE;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: rollback_payments",
    "definition": "CREATE FUNCTION rollback_payments()\\nRETURNS TABLE(billing_id integer, old_status payment_status, old_amount numeric, old_balance numeric, reset_success boolean)\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.rollback_payments()\n RETURNS TABLE(billing_id integer, old_status payment_status, old_amount numeric, old_balance numeric, reset_success boolean)\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n    payment_rec RECORD;\r\n    billing_json_key TEXT;\r\n    billing_data JSONB;\r\n    update_count INTEGER;\r\nBEGIN\r\n    -- Create temporary table to log results\r\n    CREATE TEMP TABLE IF NOT EXISTS rollback_results (\r\n        billing_id INTEGER,\r\n        old_status payment_status,\r\n        old_amount NUMERIC,\r\n        old_balance NUMERIC,\r\n        reset_success BOOLEAN\r\n    );\r\n\r\n    -- Process each payment in reverse chronological order\r\n    FOR payment_rec IN (\r\n        SELECT * FROM payments \r\n        ORDER BY created_at DESC\r\n    ) LOOP\r\n        -- For each billing ID in the payment's billing_changes\r\n        FOR billing_json_key, billing_data IN \r\n            SELECT * FROM jsonb_each(payment_rec.billing_changes)\r\n        LOOP\r\n            -- Reset the billing record to its original state\r\n            UPDATE billings \r\n            SET \r\n                status = COALESCE(\r\n                    (billing_data->>'old_status')::payment_status,\r\n                    'PENDING'::payment_status\r\n                ),\r\n                paid_amount = COALESCE(\r\n                    (billing_data->>'old_amount')::numeric,\r\n                    0\r\n                ),\r\n                balance = COALESCE(\r\n                    (billing_data->>'old_balance')::numeric,\r\n                    amount\r\n                ),\r\n                updated_at = NOW()\r\n            WHERE id = billing_json_key::integer\r\n            RETURNING id INTO update_count;\r\n\r\n            -- Log the result\r\n            INSERT INTO rollback_results (\r\n                billing_id,\r\n                old_status,\r\n                old_amount,\r\n                old_balance,\r\n                reset_success\r\n            ) VALUES (\r\n                billing_json_key::integer,\r\n                (billing_data->>'old_status')::payment_status,\r\n                (billing_data->>'old_amount')::numeric,\r\n                (billing_data->>'old_balance')::numeric,\r\n                update_count IS NOT NULL\r\n            );\r\n        END LOOP;\r\n    END LOOP;\r\n\r\n    -- Delete all payments\r\n    DELETE FROM payments;\r\n\r\n    -- Return results\r\n    RETURN QUERY SELECT * FROM rollback_results;\r\n    \r\n    -- Clean up\r\n    DROP TABLE rollback_results;\r\nEND;\r\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: rollback_transaction",
    "definition": "CREATE FUNCTION rollback_transaction()\\nRETURNS void\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.rollback_transaction()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    txid text;\nBEGIN\n    txid := current_setting('app.current_transaction', true);\n    IF txid IS NOT NULL THEN\n        PERFORM set_config('app.current_transaction', NULL, true);\n        RAISE EXCEPTION 'Transaction rolled back';\n    END IF;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: update_modified_column",
    "definition": "CREATE FUNCTION update_modified_column()\\nRETURNS trigger\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.update_modified_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: update_payment_status",
    "definition": "CREATE FUNCTION update_payment_status()\\nRETURNS trigger\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.update_payment_status()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.due_date < CURRENT_DATE AND NEW.status = 'PENDING' THEN\n        NEW.status = 'OVERDUE';\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: update_rental_unit_status_on_lease_change",
    "definition": "CREATE FUNCTION update_rental_unit_status_on_lease_change()\\nRETURNS trigger\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.update_rental_unit_status_on_lease_change()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Input validation\n    IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN\n        IF NEW.rental_unit_id IS NULL THEN\n            RAISE EXCEPTION 'rental_unit_id cannot be null';\n        END IF;\n        \n        -- Validate rental unit exists\n        IF NOT EXISTS (SELECT 1 FROM rental_unit WHERE id = NEW.rental_unit_id) THEN\n            RAISE EXCEPTION 'Invalid rental_unit_id: %', NEW.rental_unit_id;\n        END IF;\n        \n        -- Check for existing active leases\n        IF EXISTS (\n            SELECT 1 \n            FROM leases \n            WHERE rental_unit_id = NEW.rental_unit_id \n            AND status = 'ACTIVE'\n            AND id != COALESCE(NEW.id, -1)\n        ) THEN\n            RAISE EXCEPTION 'Rental unit % already has an active lease', NEW.rental_unit_id;\n        END IF;\n    END IF;\n\n    -- Handle different operations\n    IF TG_OP = 'INSERT' THEN\n        -- Set the rental unit status to 'OCCUPIED' when a lease is created\n        UPDATE rental_unit \n        SET rental_unit_status = 'OCCUPIED',\n            updated_at = CURRENT_TIMESTAMP\n        WHERE id = NEW.rental_unit_id;\n\n    ELSIF TG_OP = 'UPDATE' THEN\n        -- If the rental unit has changed, update the old unit to 'VACANT'\n        IF OLD.rental_unit_id IS NOT NULL AND OLD.rental_unit_id != NEW.rental_unit_id THEN\n            UPDATE rental_unit \n            SET rental_unit_status = 'VACANT',\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = OLD.rental_unit_id;\n        END IF;\n\n        -- Set the new rental unit status to 'OCCUPIED'\n        IF NEW.rental_unit_id IS NOT NULL THEN\n            UPDATE rental_unit \n            SET rental_unit_status = 'OCCUPIED',\n                updated_at = CURRENT_TIMESTAMP\n            WHERE id = NEW.rental_unit_id;\n        END IF;\n\n    ELSIF TG_OP = 'DELETE' THEN\n        -- Validate old rental unit exists\n        IF NOT EXISTS (SELECT 1 FROM rental_unit WHERE id = OLD.rental_unit_id) THEN\n            RAISE EXCEPTION 'Invalid rental_unit_id in deleted record: %', OLD.rental_unit_id;\n        END IF;\n\n        -- Set the rental unit status to 'VACANT' when a lease is deleted\n        UPDATE rental_unit \n        SET rental_unit_status = 'VACANT',\n            updated_at = CURRENT_TIMESTAMP\n        WHERE id = OLD.rental_unit_id;\n    END IF;\n\n    RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;\n\nEXCEPTION\n    WHEN others THEN\n        RAISE;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "FUNCTION: update_updated_at_column",
    "definition": "CREATE FUNCTION update_updated_at_column()\\nRETURNS trigger\\nLANGUAGE plpgsql\\nAS $$\\nCREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = TIMEZONE('utc'::text, NOW());\n    RETURN NEW;\nEND;\n$function$\n\\n$$;"
  },
  {
    "name": "TABLE: ai_prompts",
    "definition": "CREATE TABLE ai_prompts (\n    prompt_id text NOT NULL,\n    prompt_text text NOT NULL,\n    updated_at timestamp with time zone NOT NULL DEFAULT now()\n);\n\nALTER TABLE ai_prompts ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated read access\" ON ai_prompts\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (true);\n\nALTER TABLE ai_prompts ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated update access\" ON ai_prompts\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (true)\n    WITH CHECK (true);\n\nALTER TABLE ai_prompts ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to read prompts\" ON ai_prompts\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (true);\n\nALTER TABLE ai_prompts ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to update prompts\" ON ai_prompts\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (true)\n    WITH CHECK (true);\n\nALTER TABLE ai_prompts ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated insert access\" ON ai_prompts\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (true);\n\n"
  },
  {
    "name": "TABLE: attendees",
    "definition": "CREATE TABLE attendees (\n    id uuid NOT NULL DEFAULT uuid_generate_v4(),\n    basic_info jsonb DEFAULT '{}'::jsonb,\n    event_id uuid NOT NULL,\n    ticket_info jsonb DEFAULT '{}'::jsonb,\n    is_paid boolean DEFAULT false,\n    is_printed boolean DEFAULT false,\n    received_by uuid,\n    qr_link text,\n    reference_code_url text,\n    attendance_status text DEFAULT 'notRegistered'::text,\n    qr_scan_info jsonb[] DEFAULT '{}'::jsonb[],\n    created_at timestamp with time zone DEFAULT now(),\n    updated_at timestamp with time zone DEFAULT now(),\n    org_id uuid NOT NULL\n);\n\nALTER TABLE attendees ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Public can view their own registrations\" ON attendees\n    AS PERMISSIVE\n    FOR r\n    TO unknown (OID=0)\n    USING ((EXISTS ( SELECT 1\n   FROM events\n  WHERE ((events.id = attendees.event_id) AND (events.is_public = true)))));\n\nALTER TABLE attendees ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Public can register for public events\" ON attendees\n    AS PERMISSIVE\n    FOR a\n    TO unknown (OID=0)\n    USING ()\n    WITH CHECK ((EXISTS ( SELECT 1\n   FROM events\n  WHERE ((events.id = attendees.event_id) AND (events.is_public = true)))));\n\nALTER TABLE attendees ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Only admins can delete attendees\" ON attendees\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.org_id = attendees.org_id) AND (profiles.role = ANY (ARRAY['org_admin'::user_role, 'event_admin'::user_role]))))))));\n\nALTER TABLE attendees ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Admins can view all attendees\" ON attendees\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.org_id = attendees.org_id) AND (profiles.role = ANY (ARRAY['org_admin'::user_role, 'event_admin'::user_role]))))))));\n\nALTER TABLE attendees ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Only admins can update attendees\" ON attendees\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.org_id = attendees.org_id) AND (profiles.role = ANY (ARRAY['org_admin'::user_role, 'event_admin'::user_role]))))))));\n\nCREATE TRIGGER update_attendees_updated_at\\n    BEFORE DELETE ON attendees\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: billings",
    "definition": "CREATE TABLE billings (\n    id integer NOT NULL DEFAULT nextval('billings_id_seq'::regclass),\n    lease_id integer NOT NULL,\n    type billing_type NOT NULL,\n    utility_type utility_type,\n    amount numeric(10,2) NOT NULL,\n    paid_amount numeric(10,2) DEFAULT 0,\n    balance numeric(10,2) NOT NULL,\n    status payment_status NOT NULL DEFAULT 'PENDING'::payment_status,\n    due_date date NOT NULL,\n    billing_date date NOT NULL,\n    penalty_amount numeric(10,2) DEFAULT 0,\n    notes text,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone,\n    meter_id integer\n);\n\nALTER TABLE billings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read billings\" ON billings\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('billings.read'::app_permission));\n\nALTER TABLE billings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create billings\" ON billings\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('billings.create'::app_permission));\n\nALTER TABLE billings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete billings\" ON billings\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('billings.delete'::app_permission));\n\nALTER TABLE billings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update billings\" ON billings\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('billings.update'::app_permission))\n    WITH CHECK (authorize('billings.update'::app_permission));\n\nCREATE TRIGGER update_billings_updated_at\\n    BEFORE DELETE ON billings\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: bookings",
    "definition": "CREATE TABLE bookings (\n    id uuid NOT NULL DEFAULT gen_random_uuid(),\n    created_at timestamp with time zone NOT NULL DEFAULT now(),\n    status text NOT NULL DEFAULT 'Pending'::text,\n    name text NOT NULL,\n    email text NOT NULL,\n    phone text NOT NULL,\n    dob date,\n    preferred_contact text,\n    instagram_handle text,\n    facebook_profile text,\n    category text,\n    placement text,\n    tattoo_size numeric,\n    is_color boolean NOT NULL DEFAULT false,\n    is_cover_up boolean NOT NULL DEFAULT false,\n    complexity integer,\n    creative_freedom integer,\n    specific_reqs text,\n    must_haves text,\n    color_prefs text,\n    placement_notes text,\n    requested_date timestamp with time zone,\n    requested_time text,\n    artist_preference text,\n    estimated_duration integer,\n    estimated_sessions integer,\n    pricing_details jsonb,\n    reference_image_urls jsonb,\n    terms_agreed boolean NOT NULL DEFAULT false,\n    medical_confirmed boolean NOT NULL DEFAULT false,\n    age_confirmed boolean NOT NULL DEFAULT false,\n    saved_reply_recommendations jsonb,\n    admin_notes text,\n    primary_tattoo_style text,\n    style_description text\n);\n\nALTER TABLE bookings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authorized update access\" ON bookings\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('bookings.update'::app_permission))\n    WITH CHECK (authorize('bookings.update'::app_permission));\n\nALTER TABLE bookings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authorized read access\" ON bookings\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('bookings.read'::app_permission));\n\nALTER TABLE bookings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow anonymous booking requests\" ON bookings\n    AS PERMISSIVE\n    FOR a\n    TO anon\n    USING ()\n    WITH CHECK (((char_length(name) > 0) AND (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'::text) AND (phone IS NOT NULL) AND (terms_agreed = true) AND (medical_confirmed = true) AND (age_confirmed = true)));\n\nALTER TABLE bookings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authorized delete access\" ON bookings\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('bookings.delete'::app_permission));\n\n"
  },
  {
    "name": "TABLE: budgets",
    "definition": "CREATE TABLE budgets (\n    id bigint NOT NULL,\n    project_name text NOT NULL,\n    project_description text,\n    project_category text,\n    planned_amount numeric(10,2) NOT NULL,\n    pending_amount numeric(10,2) DEFAULT 0,\n    actual_amount numeric(10,2) DEFAULT 0,\n    budget_items jsonb DEFAULT '[]'::jsonb,\n    status text DEFAULT 'planned'::text,\n    start_date timestamp with time zone,\n    end_date timestamp with time zone,\n    property_id integer NOT NULL,\n    created_by uuid,\n    created_at timestamp with time zone DEFAULT now(),\n    updated_at timestamp with time zone DEFAULT now()\n);\n\nALTER TABLE budgets ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to update budgets\" ON budgets\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (true)\n    WITH CHECK (true);\n\nALTER TABLE budgets ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to delete budgets\" ON budgets\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (true);\n\nALTER TABLE budgets ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to insert budgets\" ON budgets\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (true);\n\nALTER TABLE budgets ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to select budgets\" ON budgets\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (true);\n\n"
  },
  {
    "name": "TABLE: events",
    "definition": "CREATE TABLE events (\n    id uuid NOT NULL DEFAULT uuid_generate_v4(),\n    event_name text NOT NULL,\n    event_long_name text,\n    event_url text,\n    other_info jsonb DEFAULT '{}'::jsonb,\n    ticketing_data jsonb[] DEFAULT '{}'::jsonb[],\n    is_public boolean DEFAULT false,\n    created_at timestamp with time zone DEFAULT now(),\n    updated_at timestamp with time zone DEFAULT now(),\n    created_by uuid NOT NULL,\n    org_id uuid NOT NULL,\n    payment_timeout_minutes integer DEFAULT 15\n);\n\nALTER TABLE events ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Events are updatable by admins\" ON events\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.org_id = events.org_id) AND (profiles.role = ANY (ARRAY['org_admin'::user_role, 'event_admin'::user_role]))))))));\n\nALTER TABLE events ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Public can view event_url of public events\" ON events\n    AS PERMISSIVE\n    FOR r\n    TO unknown (OID=0)\n    USING (is_public);\n\nALTER TABLE events ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Events are deletable by admins\" ON events\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.org_id = events.org_id) AND (profiles.role = ANY (ARRAY['org_admin'::user_role, 'event_admin'::user_role]))))))));\n\nALTER TABLE events ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can create events for their organization\" ON events\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND (profiles.org_id = events.org_id) AND (profiles.role = ANY (ARRAY['super_admin'::user_role, 'org_admin'::user_role, 'event_admin'::user_role]))))));\n\nALTER TABLE events ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Events are viewable based on is_public flag and org membership\" ON events\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING ((is_public OR (EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.org_id = events.org_id) AND (profiles.role = ANY (ARRAY['org_admin'::user_role, 'event_admin'::user_role, 'user'::user_role])))))))));\n\nCREATE TRIGGER update_events_updated_at\\n    BEFORE DELETE ON events\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: expenses",
    "definition": "CREATE TABLE expenses (\n    id integer NOT NULL,\n    property_id integer,\n    amount numeric(10,2) NOT NULL,\n    description text NOT NULL,\n    type expense_type NOT NULL,\n    status expense_status NOT NULL DEFAULT 'PENDING'::expense_status,\n    created_by uuid,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    expense_date timestamp with time zone\n);\n\nALTER TABLE expenses ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update expenses\" ON expenses\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('expenses.update'::app_permission))\n    WITH CHECK (authorize('expenses.update'::app_permission));\n\nALTER TABLE expenses ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create expenses\" ON expenses\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('expenses.create'::app_permission));\n\nALTER TABLE expenses ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete expenses\" ON expenses\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('expenses.delete'::app_permission));\n\nALTER TABLE expenses ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read expenses\" ON expenses\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('expenses.read'::app_permission));\n\n"
  },
  {
    "name": "TABLE: floors",
    "definition": "CREATE TABLE floors (\n    id integer NOT NULL DEFAULT nextval('floors_id_seq'::regclass),\n    property_id integer NOT NULL,\n    floor_number integer NOT NULL,\n    wing text,\n    status floor_status NOT NULL DEFAULT 'ACTIVE'::floor_status,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone\n);\n\nALTER TABLE floors ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read floors\" ON floors\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('floors.read'::app_permission));\n\nALTER TABLE floors ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create floors\" ON floors\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('floors.create'::app_permission));\n\nALTER TABLE floors ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete floors\" ON floors\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('floors.delete'::app_permission));\n\nALTER TABLE floors ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update floors\" ON floors\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('floors.update'::app_permission))\n    WITH CHECK (authorize('floors.update'::app_permission));\n\nCREATE TRIGGER update_floors_modtime\\n    BEFORE DELETE ON floors\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();"
  },
  {
    "name": "TABLE: idcards",
    "definition": "CREATE TABLE idcards (\n    id uuid NOT NULL DEFAULT uuid_generate_v4(),\n    template_id uuid,\n    front_image text,\n    back_image text,\n    data jsonb,\n    created_at timestamp with time zone DEFAULT now(),\n    org_id uuid NOT NULL\n);\n\nALTER TABLE idcards ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable idcard update access based on role\" ON idcards\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = 'id_gen_admin'::user_role) AND (profiles.org_id = idcards.org_id)))))));\n\nALTER TABLE idcards ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable idcard insert access based on role\" ON idcards\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = ANY (ARRAY['org_admin'::user_role, 'id_gen_admin'::user_role, 'id_gen_user'::user_role])) AND (profiles.org_id = idcards.org_id)))))));\n\nALTER TABLE idcards ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable idcard delete access based on role\" ON idcards\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = 'id_gen_admin'::user_role) AND (profiles.org_id = idcards.org_id)))))));\n\nALTER TABLE idcards ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable idcard read access based on role\" ON idcards\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = ANY (ARRAY['org_admin'::user_role, 'id_gen_admin'::user_role, 'id_gen_user'::user_role])) AND (profiles.org_id = idcards.org_id)))))));\n\n"
  },
  {
    "name": "TABLE: lease_tenants",
    "definition": "CREATE TABLE lease_tenants (\n    id integer NOT NULL DEFAULT nextval('lease_tenants_id_seq'::regclass),\n    lease_id integer NOT NULL,\n    tenant_id integer NOT NULL,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now())\n);\n\nALTER TABLE lease_tenants ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow manage lease_tenants\" ON lease_tenants\n    AS PERMISSIVE\n    FOR A\n    TO authenticated\n    USING (authorize('leases.update'::app_permission));\n\nALTER TABLE lease_tenants ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read lease_tenants\" ON lease_tenants\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('leases.read'::app_permission));\n\n"
  },
  {
    "name": "TABLE: leases",
    "definition": "CREATE TABLE leases (\n    id integer NOT NULL DEFAULT nextval('leases_id_seq'::regclass),\n    rental_unit_id integer NOT NULL,\n    name text NOT NULL,\n    start_date date NOT NULL,\n    end_date date NOT NULL,\n    rent_amount numeric(10,2) NOT NULL,\n    security_deposit numeric(10,2) NOT NULL,\n    balance numeric(10,2) DEFAULT 0,\n    notes text,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone,\n    created_by uuid,\n    terms_month integer,\n    status lease_status NOT NULL DEFAULT 'ACTIVE'::lease_status,\n    unit_type unit_type\n);\n\nALTER TABLE leases ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update leases\" ON leases\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('leases.update'::app_permission))\n    WITH CHECK (authorize('leases.update'::app_permission));\n\nALTER TABLE leases ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete leases\" ON leases\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('leases.delete'::app_permission));\n\nALTER TABLE leases ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create leases\" ON leases\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('leases.create'::app_permission));\n\nALTER TABLE leases ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read leases\" ON leases\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('leases.read'::app_permission));\n\nCREATE TRIGGER update_leases_updated_at\\n    BEFORE DELETE ON leases\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: maintenance",
    "definition": "CREATE TABLE maintenance (\n    id integer NOT NULL DEFAULT nextval('maintenance_id_seq'::regclass),\n    location_id integer NOT NULL,\n    title text NOT NULL,\n    description text NOT NULL,\n    status maintenance_status DEFAULT 'PENDING'::maintenance_status,\n    completed_at timestamp with time zone,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone\n);\n\nALTER TABLE maintenance ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create maintenance\" ON maintenance\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('maintenance.create'::app_permission));\n\nALTER TABLE maintenance ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read maintenance\" ON maintenance\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('maintenance.read'::app_permission));\n\nALTER TABLE maintenance ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete maintenance\" ON maintenance\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('maintenance.delete'::app_permission));\n\nALTER TABLE maintenance ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update maintenance\" ON maintenance\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('maintenance.update'::app_permission))\n    WITH CHECK (authorize('maintenance.update'::app_permission));\n\nCREATE TRIGGER update_maintenance_updated_at\\n    BEFORE DELETE ON maintenance\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: meters",
    "definition": "CREATE TABLE meters (\n    id integer NOT NULL DEFAULT nextval('meters_id_seq'::regclass),\n    name text NOT NULL,\n    location_type meter_location_type NOT NULL,\n    property_id integer,\n    floor_id integer,\n    rental_unit_id integer,\n    type utility_type NOT NULL,\n    is_active boolean DEFAULT true,\n    status meter_status NOT NULL DEFAULT 'ACTIVE'::meter_status,\n    notes text,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    initial_reading numeric(10,2)\n);\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create meters\" ON meters\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('meters.create'::app_permission));\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update meters\" ON meters\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('meters.update'::app_permission))\n    WITH CHECK (authorize('meters.update'::app_permission));\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read meters\" ON meters\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('meters.read'::app_permission));\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete meters\" ON meters\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('meters.delete'::app_permission));\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to update meters\" ON meters\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (true)\n    WITH CHECK ((auth.uid() IS NOT NULL));\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to select meters\" ON meters\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (true);\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to insert meters\" ON meters\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK ((auth.uid() IS NOT NULL));\n\nALTER TABLE meters ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to delete meters\" ON meters\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (true);\n\n"
  },
  {
    "name": "TABLE: organizations",
    "definition": "CREATE TABLE organizations (\n    id uuid NOT NULL DEFAULT gen_random_uuid(),\n    name text NOT NULL,\n    created_at timestamp with time zone DEFAULT now(),\n    updated_at timestamp with time zone DEFAULT now()\n);\n\nALTER TABLE organizations ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Organizations are viewable by authenticated users\" ON organizations\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (true);\n\nALTER TABLE organizations ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Organizations are deletable by super admin\" ON organizations\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::user_role)))));\n\nALTER TABLE organizations ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Organizations are insertable by super admin\" ON organizations\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::user_role)))));\n\nALTER TABLE organizations ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Organizations are updatable by super admin\" ON organizations\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND (profiles.role = 'super_admin'::user_role)))));\n\nCREATE TRIGGER update_organizations_modtime\\n    BEFORE DELETE ON organizations\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();\n\nCREATE TRIGGER update_organizations_updated_at\\n    BEFORE DELETE ON organizations\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: payment_allocations",
    "definition": "CREATE TABLE payment_allocations (\n    id integer NOT NULL DEFAULT nextval('payment_allocations_id_seq'::regclass),\n    payment_id integer,\n    billing_id integer,\n    amount numeric NOT NULL,\n    created_at timestamp with time zone DEFAULT now()\n);\n\n"
  },
  {
    "name": "TABLE: payments",
    "definition": "CREATE TABLE payments (\n    id integer NOT NULL DEFAULT nextval('payments_id_seq'::regclass),\n    amount numeric(10,2) NOT NULL,\n    method payment_method NOT NULL,\n    reference_number text,\n    paid_by text NOT NULL,\n    paid_at timestamp with time zone NOT NULL,\n    notes text,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    receipt_url text,\n    created_by uuid,\n    updated_by uuid,\n    updated_at timestamp with time zone,\n    billing_ids integer[] NOT NULL,\n    billing_id integer\n);\n\nALTER TABLE payments ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update payments\" ON payments\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('payments.update'::app_permission))\n    WITH CHECK (authorize('payments.update'::app_permission));\n\nALTER TABLE payments ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read payments\" ON payments\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('payments.read'::app_permission));\n\nALTER TABLE payments ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create payments\" ON payments\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('payments.create'::app_permission));\n\nALTER TABLE payments ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete payments\" ON payments\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('payments.delete'::app_permission));\n\n"
  },
  {
    "name": "TABLE: penalty_configs",
    "definition": "CREATE TABLE penalty_configs (\n    id integer NOT NULL DEFAULT nextval('penalty_configs_id_seq'::regclass),\n    type billing_type NOT NULL,\n    grace_period integer NOT NULL,\n    penalty_percentage numeric(5,2) NOT NULL,\n    compound_period integer,\n    max_penalty_percentage numeric(5,2),\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone\n);\n\nALTER TABLE penalty_configs ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow manage penalty_configs\" ON penalty_configs\n    AS PERMISSIVE\n    FOR A\n    TO authenticated\n    USING (authorize('penalties.configure'::app_permission));\n\nALTER TABLE penalty_configs ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read penalty_configs\" ON penalty_configs\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('penalties.configure'::app_permission));\n\nCREATE TRIGGER update_penalty_configs_updated_at\\n    BEFORE DELETE ON penalty_configs\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: profiles",
    "definition": "CREATE TABLE profiles (\n    id uuid NOT NULL,\n    email text,\n    role user_role DEFAULT 'user'::user_role,\n    created_at timestamp with time zone DEFAULT now(),\n    updated_at timestamp with time zone DEFAULT now(),\n    org_id uuid,\n    context jsonb DEFAULT '{}'::jsonb\n);\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Profiles are viewable by users based on role\" ON profiles\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (\nCASE\n    WHEN ((auth.jwt() ->> 'role'::text) = 'super_admin'::text) THEN true\n    ELSE (auth.uid() = id)\nEND);\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can delete profile based on role\" ON profiles\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (\nCASE\n    WHEN ((auth.jwt() ->> 'role'::text) = 'super_admin'::text) THEN true\n    ELSE (auth.uid() = id)\nEND);\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can insert their own profile\" ON profiles\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK ((auth.uid() = id));\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Users can update profile based on role\" ON profiles\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (\nCASE\n    WHEN ((auth.jwt() ->> 'role'::text) = 'super_admin'::text) THEN true\n    ELSE (auth.uid() = id)\nEND);\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow auth admin to read profiles\" ON profiles\n    AS PERMISSIVE\n    FOR r\n    TO supabase_auth_admin\n    USING (true);\n\nCREATE TRIGGER update_profiles_updated_at\\n    BEFORE DELETE ON profiles\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: properties",
    "definition": "CREATE TABLE properties (\n    id integer NOT NULL DEFAULT nextval('properties_id_seq'::regclass),\n    name text NOT NULL,\n    address text NOT NULL,\n    type text NOT NULL,\n    status property_status NOT NULL DEFAULT 'ACTIVE'::property_status,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone\n);\n\nALTER TABLE properties ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update properties\" ON properties\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('properties.update'::app_permission))\n    WITH CHECK (authorize('properties.update'::app_permission));\n\nALTER TABLE properties ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read properties\" ON properties\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('properties.read'::app_permission));\n\nALTER TABLE properties ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create properties\" ON properties\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('properties.create'::app_permission));\n\nALTER TABLE properties ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete properties\" ON properties\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('properties.delete'::app_permission));\n\nCREATE TRIGGER update_properties_modtime\\n    BEFORE DELETE ON properties\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();"
  },
  {
    "name": "TABLE: readings",
    "definition": "CREATE TABLE readings (\n    id integer NOT NULL DEFAULT nextval('readings_id_seq'::regclass),\n    meter_id integer NOT NULL,\n    reading numeric(10,2) NOT NULL,\n    reading_date date NOT NULL,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    meter_name text,\n    consumption numeric(10,2),\n    cost numeric(10,2),\n    cost_per_unit numeric(10,2),\n    previous_reading numeric(10,2)\n);\n\nALTER TABLE readings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create readings\" ON readings\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('readings.create'::app_permission));\n\nALTER TABLE readings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read readings\" ON readings\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('readings.read'::app_permission));\n\nALTER TABLE readings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete readings\" ON readings\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('readings.delete'::app_permission));\n\nALTER TABLE readings ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update readings\" ON readings\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('readings.update'::app_permission))\n    WITH CHECK (authorize('readings.update'::app_permission));\n\n"
  },
  {
    "name": "TABLE: rental_unit",
    "definition": "CREATE TABLE rental_unit (\n    id integer NOT NULL DEFAULT nextval('locations_id_seq'::regclass),\n    name text NOT NULL,\n    capacity integer NOT NULL,\n    rental_unit_status location_status NOT NULL DEFAULT 'VACANT'::location_status,\n    base_rate numeric(10,2) NOT NULL,\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone,\n    property_id integer NOT NULL,\n    floor_id integer NOT NULL,\n    type text NOT NULL,\n    amenities jsonb DEFAULT '{}'::jsonb,\n    number integer NOT NULL\n);\n\nALTER TABLE rental_unit ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create rental_unit\" ON rental_unit\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('rental_units.create'::app_permission));\n\nALTER TABLE rental_unit ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update rental_unit\" ON rental_unit\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('rental_units.update'::app_permission))\n    WITH CHECK (authorize('rental_units.update'::app_permission));\n\nALTER TABLE rental_unit ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read rental_unit\" ON rental_unit\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('rental_units.read'::app_permission));\n\nALTER TABLE rental_unit ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete rental_unit\" ON rental_unit\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('rental_units.delete'::app_permission));\n\nCREATE TRIGGER update_locations_updated_at\\n    BEFORE DELETE ON rental_unit\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: role_permissions",
    "definition": "CREATE TABLE role_permissions (\n    id bigint NOT NULL,\n    role app_role NOT NULL,\n    permission app_permission NOT NULL\n);\n\nALTER TABLE role_permissions ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow authenticated users to read role_permissions\" ON role_permissions\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (true);\n\n"
  },
  {
    "name": "TABLE: templates",
    "definition": "CREATE TABLE templates (\n    id uuid NOT NULL DEFAULT uuid_generate_v4(),\n    user_id uuid,\n    name text NOT NULL,\n    front_background text,\n    back_background text,\n    orientation text,\n    created_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,\n    updated_at timestamp with time zone DEFAULT CURRENT_TIMESTAMP,\n    template_elements jsonb NOT NULL,\n    org_id uuid\n);\n\nALTER TABLE templates ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable template delete access based on role\" ON templates\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = 'id_gen_admin'::user_role) AND (profiles.org_id = templates.org_id)))))));\n\nALTER TABLE templates ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable template insert access based on role\" ON templates\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = ANY (ARRAY['org_admin'::user_role, 'id_gen_admin'::user_role])) AND (templates.org_id = profiles.org_id)))))));\n\nALTER TABLE templates ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable template update access based on role\" ON templates\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = 'id_gen_admin'::user_role) AND (profiles.org_id = templates.org_id)))))));\n\nALTER TABLE templates ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Enable template read access based on role\" ON templates\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING ((EXISTS ( SELECT 1\n   FROM profiles\n  WHERE ((profiles.id = auth.uid()) AND ((profiles.role = 'super_admin'::user_role) OR ((profiles.role = ANY (ARRAY['org_admin'::user_role, 'id_gen_admin'::user_role, 'id_gen_user'::user_role])) AND (profiles.org_id = templates.org_id)))))));\n\nCREATE TRIGGER delete_template_cascade\\n    BEFORE INSERT ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION delete_template_cascade();\n\nCREATE TRIGGER enforce_template_org_id\\n    BEFORE DELETE ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION check_template_org_id();\n\nCREATE TRIGGER update_template_modtime\\n    BEFORE DELETE ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();\n\nCREATE TRIGGER update_templates_updated_at\\n    BEFORE DELETE ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: tenants",
    "definition": "CREATE TABLE tenants (\n    id integer NOT NULL DEFAULT nextval('tenants_id_seq'::regclass),\n    name text NOT NULL,\n    contact_number text,\n    email character varying(255),\n    created_at timestamp with time zone NOT NULL DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp with time zone,\n    auth_id uuid,\n    emergency_contact jsonb,\n    tenant_status tenant_status NOT NULL DEFAULT 'PENDING'::tenant_status,\n    created_by uuid\n);\n\nALTER TABLE tenants ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow create tenants\" ON tenants\n    AS PERMISSIVE\n    FOR a\n    TO authenticated\n    USING ()\n    WITH CHECK (authorize('tenants.create'::app_permission));\n\nALTER TABLE tenants ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow delete tenants\" ON tenants\n    AS PERMISSIVE\n    FOR d\n    TO authenticated\n    USING (authorize('tenants.delete'::app_permission));\n\nALTER TABLE tenants ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow update tenants\" ON tenants\n    AS PERMISSIVE\n    FOR w\n    TO authenticated\n    USING (authorize('tenants.update'::app_permission))\n    WITH CHECK (authorize('tenants.update'::app_permission));\n\nALTER TABLE tenants ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow read tenants\" ON tenants\n    AS PERMISSIVE\n    FOR r\n    TO authenticated\n    USING (authorize('tenants.read'::app_permission));\n\nCREATE TRIGGER update_tenants_updated_at\\n    BEFORE DELETE ON tenants\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TABLE: user_roles",
    "definition": "CREATE TABLE user_roles (\n    id bigint NOT NULL,\n    user_id uuid NOT NULL,\n    role app_role NOT NULL\n);\n\nALTER TABLE user_roles ENABLE ROW LEVEL SECURITY;\nCREATE POLICY \"Allow auth admin to read user roles\" ON user_roles\n    AS PERMISSIVE\n    FOR r\n    TO supabase_auth_admin\n    USING (true);\n\n"
  },
  {
    "name": "TRIGGER: attendees__update_attendees_updated_at",
    "definition": "CREATE TRIGGER update_attendees_updated_at\\n    BEFORE DELETE ON attendees\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: billings__update_billings_updated_at",
    "definition": "CREATE TRIGGER update_billings_updated_at\\n    BEFORE DELETE ON billings\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: events__update_events_updated_at",
    "definition": "CREATE TRIGGER update_events_updated_at\\n    BEFORE DELETE ON events\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: floors__update_floors_modtime",
    "definition": "CREATE TRIGGER update_floors_modtime\\n    BEFORE DELETE ON floors\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();"
  },
  {
    "name": "TRIGGER: leases__update_leases_updated_at",
    "definition": "CREATE TRIGGER update_leases_updated_at\\n    BEFORE DELETE ON leases\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: maintenance__update_maintenance_updated_at",
    "definition": "CREATE TRIGGER update_maintenance_updated_at\\n    BEFORE DELETE ON maintenance\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: organizations__update_organizations_modtime",
    "definition": "CREATE TRIGGER update_organizations_modtime\\n    BEFORE DELETE ON organizations\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();"
  },
  {
    "name": "TRIGGER: organizations__update_organizations_updated_at",
    "definition": "CREATE TRIGGER update_organizations_updated_at\\n    BEFORE DELETE ON organizations\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: penalty_configs__update_penalty_configs_updated_at",
    "definition": "CREATE TRIGGER update_penalty_configs_updated_at\\n    BEFORE DELETE ON penalty_configs\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: profiles__update_profiles_updated_at",
    "definition": "CREATE TRIGGER update_profiles_updated_at\\n    BEFORE DELETE ON profiles\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: properties__update_properties_modtime",
    "definition": "CREATE TRIGGER update_properties_modtime\\n    BEFORE DELETE ON properties\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();"
  },
  {
    "name": "TRIGGER: rental_unit__update_locations_updated_at",
    "definition": "CREATE TRIGGER update_locations_updated_at\\n    BEFORE DELETE ON rental_unit\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: templates__delete_template_cascade",
    "definition": "CREATE TRIGGER delete_template_cascade\\n    BEFORE INSERT ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION delete_template_cascade();"
  },
  {
    "name": "TRIGGER: templates__enforce_template_org_id",
    "definition": "CREATE TRIGGER enforce_template_org_id\\n    BEFORE DELETE ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION check_template_org_id();"
  },
  {
    "name": "TRIGGER: templates__update_template_modtime",
    "definition": "CREATE TRIGGER update_template_modtime\\n    BEFORE DELETE ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_modified_column();"
  },
  {
    "name": "TRIGGER: templates__update_templates_updated_at",
    "definition": "CREATE TRIGGER update_templates_updated_at\\n    BEFORE DELETE ON templates\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  },
  {
    "name": "TRIGGER: tenants__update_tenants_updated_at",
    "definition": "CREATE TRIGGER update_tenants_updated_at\\n    BEFORE DELETE ON tenants\\n    FOR EACH ROW\\n    EXECUTE FUNCTION update_updated_at_column();"
  }
]