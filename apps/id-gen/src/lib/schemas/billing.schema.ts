import { z } from 'zod';

// Credit transaction schema (credit_transactions table - matches database exactly)
export const creditTransactionSchema = z.object({
	id: z.string().uuid().optional(), // Generated by database
	user_id: z.string().uuid(), // NOT NULL
	org_id: z.string().uuid(), // NOT NULL
	transaction_type: z.string(), // NOT NULL text field (not enum in database)
	amount: z.number().int(), // NOT NULL integer
	credits_before: z.number().int(), // NOT NULL integer
	credits_after: z.number().int(), // NOT NULL integer
	description: z.string().optional(), // nullable text
	reference_id: z.string().optional(), // nullable text
	metadata: z.record(z.string(), z.any()).optional(), // nullable jsonb
	created_at: z.string().datetime().optional(), // nullable timestamp
	updated_at: z.string().datetime().optional() // nullable timestamp
});

// Credit transaction creation input
export const creditTransactionInputSchema = creditTransactionSchema.omit({
	id: true,
	credits_before: true,
	credits_after: true,
	created_at: true,
	updated_at: true
});

// Payment method enum (matches database)
export const paymentMethodSchema = z.enum([
	'gcash',
	'paymaya',
	'card',
	'online_banking',
	'bank_transfer'
]);

// Payment record schema (payments table)
export const paymentSchema = z.object({
	id: z.number().int().optional(),
	amount: z.number(),
	method: paymentMethodSchema,
	reference_number: z.string().max(100),
	paid_by: z.string().max(100),
	paid_at: z.string().datetime(),
	notes: z.string().max(500).optional(),
	created_at: z.string().datetime().optional(),
	receipt_url: z.string().url().optional(),
	created_by: z.string().uuid(),
	updated_by: z.string().uuid().optional(),
	updated_at: z.string().datetime().optional(),
	billing_ids: z.array(z.number().int()).default([]),
	billing_id: z.number().int().optional(),
	reverted_at: z.string().datetime().optional(),
	reverted_by: z.string().uuid().optional(),
	revert_reason: z.string().max(200).optional()
});

// Payment creation input schema
export const paymentInputSchema = z.object({
	amount: z.number().positive(),
	method: paymentMethodSchema,
	reference_number: z.string().min(1).max(100),
	paid_by: z.string().min(1).max(100),
	paid_at: z.string().datetime(),
	notes: z.string().max(500).optional(),
	receipt_url: z.string().url().optional(),
	created_by: z.string().uuid(),
	billing_ids: z.array(z.number().int()).optional()
});

// Webhook event schema (webhook_events table)
export const webhookEventSchema = z.object({
	id: z.string().uuid().optional(),
	event_id: z.string().max(100),
	event_type: z.string().max(50),
	provider: z.string().max(20), // 'paymongo', 'stripe', etc.
	processed_at: z.string().datetime().optional(),
	raw_payload: z.record(z.string(), z.any()),
	created_at: z.string().datetime().optional()
});

// Webhook processing result schema
export const webhookProcessingResultSchema = z.object({
	success: z.boolean(),
	event_id: z.string(),
	processed_at: z.string().datetime(),
	actions_taken: z.array(z.string()).default([]),
	errors: z.array(z.string()).default([]),
	metadata: z.record(z.string(), z.any()).default({})
});

// Credit package schema (for purchasing credits)
export const creditPackageSchema = z.object({
	id: z.string(),
	name: z.string(),
	credits: z.number().int().positive(),
	price_php: z.number().positive(),
	discount_percentage: z.number().min(0).max(100).default(0),
	popular: z.boolean().default(false),
	description: z.string().optional(),
	features: z.array(z.string()).default([])
});

// Billing summary schema
export const billingSummarySchema = z.object({
	user_id: z.string().uuid(),
	org_id: z.string().uuid(),
	current_credits: z.number().int(),
	credits_used_this_month: z.number().int(),
	total_spent: z.number(),
	last_payment: z
		.object({
			amount: z.number(),
			date: z.string().datetime(),
			method: paymentMethodSchema
		})
		.optional(),
	upcoming_charges: z
		.array(
			z.object({
				description: z.string(),
				amount: z.number(),
				due_date: z.string().datetime()
			})
		)
		.default([])
});

// Usage analytics schema
export const usageAnalyticsSchema = z.object({
	user_id: z.string().uuid(),
	org_id: z.string().uuid(),
	period: z.enum(['daily', 'weekly', 'monthly', 'yearly']),
	data: z.array(
		z.object({
			date: z.string().datetime(),
			templates_created: z.number().int(),
			cards_generated: z.number().int(),
			credits_used: z.number().int(),
			credits_purchased: z.number().int()
		})
	),
	totals: z.object({
		templates_created: z.number().int(),
		cards_generated: z.number().int(),
		credits_used: z.number().int(),
		credits_purchased: z.number().int(),
		total_spent: z.number()
	})
});

// Payment refund schema
export const paymentRefundSchema = z.object({
	payment_id: z.number().int(),
	amount: z.number().positive(), // Amount to refund
	reason: z.string().max(200),
	refunded_by: z.string().uuid(),
	notes: z.string().max(500).optional()
});

// Credit adjustment schema (for admin use)
export const creditAdjustmentSchema = z.object({
	user_id: z.string().uuid(),
	org_id: z.string().uuid(),
	amount: z.number().int(), // Can be positive or negative
	reason: z.enum(['bonus', 'refund', 'correction', 'promotion', 'penalty']),
	description: z.string().max(200),
	admin_id: z.string().uuid(),
	notes: z.string().max(500).optional()
});

// Invoice type enum
export const invoiceTypeSchema = z.enum([
	'credit_purchase',
	'feature_purchase',
	'refund',
	'correction',
	'bonus'
]);

// Invoice status enum
export const invoiceStatusSchema = z.enum(['draft', 'sent', 'paid', 'void', 'overdue']);

// Invoice item type enum
export const invoiceItemTypeSchema = z.enum(['credits', 'feature', 'service', 'custom']);

// Invoice item schema (invoice_items table)
export const invoiceItemSchema = z.object({
	id: z.string().uuid().optional(),
	invoice_id: z.string().uuid(),
	item_type: invoiceItemTypeSchema,
	sku_id: z.string().optional(),
	description: z.string().min(1),
	quantity: z.number().int().positive().default(1),
	unit_price: z.number().int().default(0), // In PHP centavos
	total_price: z.number().int().default(0),
	credits_granted: z.number().int().default(0),
	metadata: z.record(z.string(), z.unknown()).default({}),
	created_at: z.string().datetime().optional()
});

// Invoice item creation input
export const invoiceItemInputSchema = invoiceItemSchema.omit({
	id: true,
	invoice_id: true,
	created_at: true
});

// Invoice schema (invoices table)
export const invoiceSchema = z.object({
	id: z.string().uuid().optional(),
	invoice_number: z.string().optional(), // Auto-generated
	user_id: z.string().uuid(),
	org_id: z.string().uuid(),
	invoice_type: invoiceTypeSchema.default('credit_purchase'),
	status: invoiceStatusSchema.default('draft'),
	subtotal: z.number().int().default(0),
	tax_amount: z.number().int().default(0),
	discount_amount: z.number().int().default(0),
	total_amount: z.number().int().default(0),
	amount_paid: z.number().int().default(0),
	issue_date: z.string().datetime().optional(),
	due_date: z.string().datetime().optional(),
	paid_at: z.string().datetime().optional(),
	voided_at: z.string().datetime().optional(),
	notes: z.string().optional(),
	internal_notes: z.string().optional(),
	payment_method: z.string().optional(),
	payment_reference: z.string().optional(),
	created_by: z.string().uuid().optional(),
	paid_by: z.string().uuid().optional(),
	voided_by: z.string().uuid().optional(),
	created_at: z.string().datetime().optional(),
	updated_at: z.string().datetime().optional()
});

// Invoice with items (for fetching)
export const invoiceWithItemsSchema = invoiceSchema.extend({
	invoice_items: z.array(invoiceItemSchema).default([]),
	user: z
		.object({
			id: z.string().uuid(),
			email: z.string().email(),
			credits_balance: z.number().int().optional()
		})
		.optional()
});

// Invoice creation input
export const invoiceCreateInputSchema = z.object({
	user_id: z.string().uuid(),
	invoice_type: invoiceTypeSchema.default('credit_purchase'),
	notes: z.string().optional(),
	internal_notes: z.string().optional(),
	due_date: z.string().datetime().optional(),
	items: z.array(invoiceItemInputSchema).min(1)
});

// Invoice update input
export const invoiceUpdateInputSchema = z.object({
	invoice_id: z.string().uuid(),
	notes: z.string().optional(),
	internal_notes: z.string().optional(),
	due_date: z.string().datetime().optional(),
	status: invoiceStatusSchema.optional()
});

// Mark invoice as paid input
export const invoiceMarkPaidInputSchema = z.object({
	invoice_id: z.string().uuid(),
	payment_method: z.string().default('manual'),
	payment_reference: z.string().optional(),
	notes: z.string().optional()
});

// Void invoice input
export const invoiceVoidInputSchema = z.object({
	invoice_id: z.string().uuid(),
	reason: z.string().min(1).max(500)
});

// Inferred types
export type CreditTransaction = z.infer<typeof creditTransactionSchema>;
export type CreditTransactionInput = z.infer<typeof creditTransactionInputSchema>;
export type PaymentMethod = z.infer<typeof paymentMethodSchema>;
export type Payment = z.infer<typeof paymentSchema>;
export type InvoiceType = z.infer<typeof invoiceTypeSchema>;
export type InvoiceStatus = z.infer<typeof invoiceStatusSchema>;
export type InvoiceItemType = z.infer<typeof invoiceItemTypeSchema>;
export type InvoiceItem = z.infer<typeof invoiceItemSchema>;
export type InvoiceItemInput = z.infer<typeof invoiceItemInputSchema>;
export type Invoice = z.infer<typeof invoiceSchema>;
export type InvoiceWithItems = z.infer<typeof invoiceWithItemsSchema>;
export type InvoiceCreateInput = z.infer<typeof invoiceCreateInputSchema>;
export type InvoiceUpdateInput = z.infer<typeof invoiceUpdateInputSchema>;
export type InvoiceMarkPaidInput = z.infer<typeof invoiceMarkPaidInputSchema>;
export type InvoiceVoidInput = z.infer<typeof invoiceVoidInputSchema>;
export type PaymentInput = z.infer<typeof paymentInputSchema>;
export type WebhookEvent = z.infer<typeof webhookEventSchema>;
export type WebhookProcessingResult = z.infer<typeof webhookProcessingResultSchema>;
export type CreditPackage = z.infer<typeof creditPackageSchema>;
export type BillingSummary = z.infer<typeof billingSummarySchema>;
export type UsageAnalytics = z.infer<typeof usageAnalyticsSchema>;
export type PaymentRefund = z.infer<typeof paymentRefundSchema>;
export type CreditAdjustment = z.infer<typeof creditAdjustmentSchema>;
