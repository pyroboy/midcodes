import { z } from 'zod';

// Credit transaction schema (credit_transactions table - matches database exactly)
export const creditTransactionSchema = z.object({
	id: z.string().uuid().optional(), // Generated by database
	user_id: z.string().uuid(), // NOT NULL
	org_id: z.string().uuid(), // NOT NULL
	transaction_type: z.string(), // NOT NULL text field (not enum in database)
	amount: z.number().int(), // NOT NULL integer
	credits_before: z.number().int(), // NOT NULL integer
	credits_after: z.number().int(), // NOT NULL integer
	description: z.string().optional(), // nullable text
	reference_id: z.string().optional(), // nullable text
	metadata: z.record(z.string(), z.any()).optional(), // nullable jsonb
	created_at: z.string().datetime().optional(), // nullable timestamp
	updated_at: z.string().datetime().optional() // nullable timestamp
});

// Credit transaction creation input
export const creditTransactionInputSchema = creditTransactionSchema.omit({
	id: true,
	credits_before: true,
	credits_after: true,
	created_at: true,
	updated_at: true
});

// Payment method enum (matches database)
export const paymentMethodSchema = z.enum([
	'gcash',
	'paymaya',
	'card',
	'online_banking',
	'bank_transfer'
]);

// Payment record schema (payments table)
export const paymentSchema = z.object({
	id: z.number().int().optional(),
	amount: z.number(),
	method: paymentMethodSchema,
	reference_number: z.string().max(100),
	paid_by: z.string().max(100),
	paid_at: z.string().datetime(),
	notes: z.string().max(500).optional(),
	created_at: z.string().datetime().optional(),
	receipt_url: z.string().url().optional(),
	created_by: z.string().uuid(),
	updated_by: z.string().uuid().optional(),
	updated_at: z.string().datetime().optional(),
	billing_ids: z.array(z.number().int()).default([]),
	billing_id: z.number().int().optional(),
	reverted_at: z.string().datetime().optional(),
	reverted_by: z.string().uuid().optional(),
	revert_reason: z.string().max(200).optional()
});

// Payment creation input schema
export const paymentInputSchema = z.object({
	amount: z.number().positive(),
	method: paymentMethodSchema,
	reference_number: z.string().min(1).max(100),
	paid_by: z.string().min(1).max(100),
	paid_at: z.string().datetime(),
	notes: z.string().max(500).optional(),
	receipt_url: z.string().url().optional(),
	created_by: z.string().uuid(),
	billing_ids: z.array(z.number().int()).optional()
});

// Webhook event schema (webhook_events table)
export const webhookEventSchema = z.object({
	id: z.string().uuid().optional(),
	event_id: z.string().max(100),
	event_type: z.string().max(50),
	provider: z.string().max(20), // 'paymongo', 'stripe', etc.
	processed_at: z.string().datetime().optional(),
	raw_payload: z.record(z.string(), z.any()),
	created_at: z.string().datetime().optional()
});

// Webhook processing result schema
export const webhookProcessingResultSchema = z.object({
	success: z.boolean(),
	event_id: z.string(),
	processed_at: z.string().datetime(),
	actions_taken: z.array(z.string()).default([]),
	errors: z.array(z.string()).default([]),
	metadata: z.record(z.string(), z.any()).default({})
});

// Credit package schema (for purchasing credits)
export const creditPackageSchema = z.object({
	id: z.string(),
	name: z.string(),
	credits: z.number().int().positive(),
	price_php: z.number().positive(),
	discount_percentage: z.number().min(0).max(100).default(0),
	popular: z.boolean().default(false),
	description: z.string().optional(),
	features: z.array(z.string()).default([])
});

// Billing summary schema
export const billingSummarySchema = z.object({
	user_id: z.string().uuid(),
	org_id: z.string().uuid(),
	current_credits: z.number().int(),
	credits_used_this_month: z.number().int(),
	total_spent: z.number(),
	last_payment: z
		.object({
			amount: z.number(),
			date: z.string().datetime(),
			method: paymentMethodSchema
		})
		.optional(),
	upcoming_charges: z
		.array(
			z.object({
				description: z.string(),
				amount: z.number(),
				due_date: z.string().datetime()
			})
		)
		.default([])
});

// Usage analytics schema
export const usageAnalyticsSchema = z.object({
	user_id: z.string().uuid(),
	org_id: z.string().uuid(),
	period: z.enum(['daily', 'weekly', 'monthly', 'yearly']),
	data: z.array(
		z.object({
			date: z.string().datetime(),
			templates_created: z.number().int(),
			cards_generated: z.number().int(),
			credits_used: z.number().int(),
			credits_purchased: z.number().int()
		})
	),
	totals: z.object({
		templates_created: z.number().int(),
		cards_generated: z.number().int(),
		credits_used: z.number().int(),
		credits_purchased: z.number().int(),
		total_spent: z.number()
	})
});

// Payment refund schema
export const paymentRefundSchema = z.object({
	payment_id: z.number().int(),
	amount: z.number().positive(), // Amount to refund
	reason: z.string().max(200),
	refunded_by: z.string().uuid(),
	notes: z.string().max(500).optional()
});

// Credit adjustment schema (for admin use)
export const creditAdjustmentSchema = z.object({
	user_id: z.string().uuid(),
	org_id: z.string().uuid(),
	amount: z.number().int(), // Can be positive or negative
	reason: z.enum(['bonus', 'refund', 'correction', 'promotion', 'penalty']),
	description: z.string().max(200),
	admin_id: z.string().uuid(),
	notes: z.string().max(500).optional()
});

// Inferred types
export type CreditTransaction = z.infer<typeof creditTransactionSchema>;
export type CreditTransactionInput = z.infer<typeof creditTransactionInputSchema>;
export type PaymentMethod = z.infer<typeof paymentMethodSchema>;
export type Payment = z.infer<typeof paymentSchema>;
export type PaymentInput = z.infer<typeof paymentInputSchema>;
export type WebhookEvent = z.infer<typeof webhookEventSchema>;
export type WebhookProcessingResult = z.infer<typeof webhookProcessingResultSchema>;
export type CreditPackage = z.infer<typeof creditPackageSchema>;
export type BillingSummary = z.infer<typeof billingSummarySchema>;
export type UsageAnalytics = z.infer<typeof usageAnalyticsSchema>;
export type PaymentRefund = z.infer<typeof paymentRefundSchema>;
export type CreditAdjustment = z.infer<typeof creditAdjustmentSchema>;
