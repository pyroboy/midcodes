import { error } from '@sveltejs/kit';
import { query, command, getRequestEvent } from '$app/server';
import { z } from 'zod';
import { addCredits, refundCredits, grantUnlimitedTemplates, grantWatermarkRemoval } from '$lib/utils/credits';
import {
	invoiceCreateInputSchema,
	invoiceMarkPaidInputSchema,
	invoiceVoidInputSchema,
	type InvoiceCreateInput,
	type InvoiceMarkPaidInput,
	type InvoiceVoidInput
} from '$lib/schemas/billing.schema';

// Helper to require admin permissions
async function requireAdminPermissions() {
	const { locals } = getRequestEvent();
	const { user } = locals;
	const adminRoles = ['super_admin', 'org_admin', 'id_gen_admin'];
	if (!user || !adminRoles.includes(user.role || '')) {
		throw error(403, 'Admin privileges required.');
	}
	// Cast supabase to any to work around missing invoices table in generated types
	// TODO: Regenerate database types to include invoices and invoice_items tables
	return { user, supabase: locals.supabase as any, org_id: locals.org_id };
}

// Get all invoices for the organization
export const getInvoices = query(async (params?: { status?: string; userId?: string; limit?: number }) => {
	const { supabase, org_id } = await requireAdminPermissions();
	if (!org_id) throw error(500, 'Org ID missing');

	let queryBuilder = supabase
		.from('invoices')
		.select(`
			*,
			invoice_items (*),
			user:profiles!invoices_user_id_fkey (id, email, credits_balance)
		`)
		.eq('org_id', org_id)
		.order('created_at', { ascending: false });

	if (params?.status) {
		queryBuilder = queryBuilder.eq('status', params.status);
	}

	if (params?.userId) {
		queryBuilder = queryBuilder.eq('user_id', params.userId);
	}

	if (params?.limit) {
		queryBuilder = queryBuilder.limit(params.limit);
	}

	const { data, error: fetchError } = await queryBuilder;

	if (fetchError) {
		console.error('Error fetching invoices:', fetchError);
		throw error(500, 'Failed to load invoices');
	}

	return data || [];
});

// Get a single invoice by ID
export const getInvoiceById = query('unchecked', async ({ invoiceId }: { invoiceId: string }) => {
	const { supabase, org_id } = await requireAdminPermissions();
	if (!org_id) throw error(500, 'Org ID missing');

	const { data, error: fetchError } = await supabase
		.from('invoices')
		.select(`
			*,
			invoice_items (*),
			user:profiles!invoices_user_id_fkey (id, email, credits_balance, unlimited_templates, remove_watermarks)
		`)
		.eq('id', invoiceId)
		.eq('org_id', org_id)
		.single();

	if (fetchError) {
		console.error('Error fetching invoice:', fetchError);
		throw error(404, 'Invoice not found');
	}

	return data;
}) as any;

// Create a new invoice
export const createInvoice = command('unchecked', async (input: InvoiceCreateInput) => {
	const { user, supabase, org_id } = await requireAdminPermissions();
	if (!org_id) throw error(500, 'Org ID missing');

	// Validate input
	const parsed = invoiceCreateInputSchema.safeParse(input);
	if (!parsed.success) {
		throw error(400, `Invalid input: ${parsed.error.message}`);
	}

	const { user_id, invoice_type, notes, internal_notes, due_date, items } = parsed.data;

	// Verify user exists in org
	const { data: targetUser, error: userError } = await supabase
		.from('profiles')
		.select('id, email')
		.eq('id', user_id)
		.eq('org_id', org_id)
		.single();

	if (userError || !targetUser) {
		throw error(404, 'Target user not found in organization');
	}

	// Calculate totals
	let subtotal = 0;
	let totalCredits = 0;
	const processedItems = items.map((item) => {
		const total = item.quantity * item.unit_price;
		subtotal += total;
		totalCredits += item.credits_granted || 0;
		return {
			...item,
			total_price: total
		};
	});

	// Create invoice (invoice_number is auto-generated by trigger)
	const { data: invoice, error: insertError } = await supabase
		.from('invoices')
		.insert({
			user_id,
			org_id,
			invoice_type,
			status: 'draft',
			subtotal,
			tax_amount: 0,
			discount_amount: 0,
			total_amount: subtotal,
			amount_paid: 0,
			notes,
			internal_notes,
			due_date,
			created_by: user.id
		})
		.select()
		.single();

	if (insertError) {
		console.error('Error creating invoice:', insertError);
		throw error(500, 'Failed to create invoice');
	}

	// Insert invoice items
	const itemsToInsert = processedItems.map((item) => ({
		invoice_id: invoice.id,
		item_type: item.item_type,
		sku_id: item.sku_id,
		description: item.description,
		quantity: item.quantity,
		unit_price: item.unit_price,
		total_price: item.total_price,
		credits_granted: item.credits_granted,
		metadata: item.metadata
	}));

	const { error: itemsError } = await supabase.from('invoice_items').insert(itemsToInsert);

	if (itemsError) {
		console.error('Error creating invoice items:', itemsError);
		// Rollback: delete the invoice
		await supabase.from('invoices').delete().eq('id', invoice.id);
		throw error(500, 'Failed to create invoice items');
	}

	await getInvoices().refresh();

	return {
		success: true,
		invoice: {
			...invoice,
			invoice_items: itemsToInsert,
			total_credits: totalCredits
		}
	};
});

// Send invoice (change status from draft to sent)
export const sendInvoice = command('unchecked', async (invoiceId: string) => {
	const { supabase, org_id } = await requireAdminPermissions();
	if (!org_id) throw error(500, 'Org ID missing');

	const { data: invoice, error: fetchError } = await supabase
		.from('invoices')
		.select('*')
		.eq('id', invoiceId)
		.eq('org_id', org_id)
		.single();

	if (fetchError || !invoice) {
		throw error(404, 'Invoice not found');
	}

	if (invoice.status !== 'draft') {
		throw error(400, 'Only draft invoices can be sent');
	}

	const { error: updateError } = await supabase
		.from('invoices')
		.update({
			status: 'sent',
			issue_date: new Date().toISOString()
		})
		.eq('id', invoiceId);

	if (updateError) {
		throw error(500, 'Failed to send invoice');
	}

	await getInvoices().refresh();
	return { success: true };
});

// Mark invoice as paid (adds credits to user)
export const markInvoicePaid = command('unchecked', async (input: InvoiceMarkPaidInput) => {
	const { user, supabase, org_id } = await requireAdminPermissions();
	if (!org_id) throw error(500, 'Org ID missing');

	const parsed = invoiceMarkPaidInputSchema.safeParse(input);
	if (!parsed.success) {
		throw error(400, `Invalid input: ${parsed.error.message}`);
	}

	const { invoice_id, payment_method, payment_reference, notes } = parsed.data;

	// Get invoice with items
	const { data: invoice, error: fetchError } = await supabase
		.from('invoices')
		.select(`
			*,
			invoice_items (*)
		`)
		.eq('id', invoice_id)
		.eq('org_id', org_id)
		.single() as { data: { id: string; status: string; user_id: string; invoice_number: string; total_amount: number; notes?: string; invoice_items?: Array<{ credits_granted: number; sku_id?: string; item_type: string; description?: string }> } | null; error: any };

	if (fetchError || !invoice) {
		throw error(404, 'Invoice not found');
	}

	if (invoice.status === 'paid') {
		throw error(400, 'Invoice is already paid');
	}

	if (invoice.status === 'void') {
		throw error(400, 'Cannot pay a voided invoice');
	}

	// Calculate total credits to add
	let totalCredits = 0;
	let hasUnlimitedTemplates = false;
	let hasRemoveWatermarks = false;

	for (const item of invoice.invoice_items || []) {
		if (item.credits_granted > 0) {
			totalCredits += item.credits_granted;
		}
		// Check for feature purchases
		if (item.sku_id === 'unlimited_templates' || item.item_type === 'feature') {
			if (item.description?.toLowerCase().includes('unlimited template')) {
				hasUnlimitedTemplates = true;
			}
			if (item.description?.toLowerCase().includes('watermark')) {
				hasRemoveWatermarks = true;
			}
		}
	}

	// Update invoice status
	const { error: updateError } = await supabase
		.from('invoices')
		.update({
			status: 'paid',
			paid_at: new Date().toISOString(),
			paid_by: user.id,
			payment_method: payment_method || 'manual',
			payment_reference,
			amount_paid: invoice.total_amount,
			notes: notes ? `${invoice.notes || ''}\n${notes}`.trim() : invoice.notes
		})
		.eq('id', invoice_id);

	if (updateError) {
		throw error(500, 'Failed to update invoice status');
	}

	// Add credits to user
	if (totalCredits > 0) {
		const creditResult = await addCredits(
			supabase,
			invoice.user_id,
			org_id,
			totalCredits,
			invoice_id,
			`Invoice ${invoice.invoice_number}`
		);

		if (!creditResult.success) {
			console.error('Failed to add credits:', creditResult.error);
			// Revert invoice status
			await supabase
				.from('invoices')
				.update({ status: 'sent', paid_at: null, paid_by: null })
				.eq('id', invoice_id);
			throw error(500, 'Failed to add credits to user');
		}
	}

	// Grant features if applicable
	if (hasUnlimitedTemplates) {
		await grantUnlimitedTemplates(supabase, invoice.user_id, org_id, invoice_id);
	}

	if (hasRemoveWatermarks) {
		await grantWatermarkRemoval(supabase, invoice.user_id, org_id, invoice_id);
	}

	await getInvoices().refresh();

	return {
		success: true,
		creditsAdded: totalCredits,
		featuresGranted: {
			unlimitedTemplates: hasUnlimitedTemplates,
			removeWatermarks: hasRemoveWatermarks
		}
	};
});

// Void an invoice
export const voidInvoice = command('unchecked', async (input: InvoiceVoidInput) => {
	const { user, supabase, org_id } = await requireAdminPermissions();
	if (!org_id) throw error(500, 'Org ID missing');

	const parsed = invoiceVoidInputSchema.safeParse(input);
	if (!parsed.success) {
		throw error(400, `Invalid input: ${parsed.error.message}`);
	}

	const { invoice_id, reason } = parsed.data;

	// Get invoice
	const { data: invoice, error: fetchError } = await supabase
		.from('invoices')
		.select(`
			*,
			invoice_items (*)
		`)
		.eq('id', invoice_id)
		.eq('org_id', org_id)
		.single() as { data: { id: string; status: string; user_id: string; invoice_number: string; internal_notes?: string; invoice_items?: Array<{ credits_granted: number }> } | null; error: any };

	if (fetchError || !invoice) {
		throw error(404, 'Invoice not found');
	}

	if (invoice.status === 'void') {
		throw error(400, 'Invoice is already voided');
	}

	// If invoice was paid, we need to reverse the credits
	let creditsReversed = 0;
	if (invoice.status === 'paid') {
		// Calculate credits that were granted
		for (const item of invoice.invoice_items || []) {
			if (item.credits_granted > 0) {
				creditsReversed += item.credits_granted;
			}
		}

		// Reverse credits if any were granted
		if (creditsReversed > 0) {
			// Create a negative refund transaction
			const refundResult = await refundCredits(
				supabase,
				invoice.user_id,
				org_id,
				-creditsReversed, // Negative to deduct
				invoice_id,
				`Voided invoice ${invoice.invoice_number}: ${reason}`
			);

			if (!refundResult.success) {
				console.error('Failed to reverse credits:', refundResult.error);
				throw error(500, 'Failed to reverse credits');
			}
		}
	}

	// Update invoice status
	const { error: updateError } = await supabase
		.from('invoices')
		.update({
			status: 'void',
			voided_at: new Date().toISOString(),
			voided_by: user.id,
			internal_notes: `${invoice.internal_notes || ''}\nVoided: ${reason}`.trim()
		})
		.eq('id', invoice_id);

	if (updateError) {
		throw error(500, 'Failed to void invoice');
	}

	await getInvoices().refresh();

	return {
		success: true,
		creditsReversed
	};
});

// Get admin audit log (recent invoice actions)
export const getAdminAuditLog = query(async (limit: number = 20) => {
	const { supabase, org_id } = await requireAdminPermissions();
	if (!org_id) throw error(500, 'Org ID missing');

	// Get recent invoices with status changes
	type InvoiceAuditRow = {
		id: string;
		invoice_number: string;
		status: string;
		invoice_type: string;
		total_amount: number;
		created_at: string;
		paid_at: string | null;
		voided_at: string | null;
		user: { email: string } | null;
		created_by_user: { email: string } | null;
		paid_by_user: { email: string } | null;
		voided_by_user: { email: string } | null;
	};
	const { data: recentInvoices, error: invoicesError } = await supabase
		.from('invoices')
		.select(`
			id,
			invoice_number,
			status,
			invoice_type,
			total_amount,
			created_at,
			paid_at,
			voided_at,
			user:profiles!invoices_user_id_fkey (email),
			created_by_user:profiles!invoices_created_by_fkey (email),
			paid_by_user:profiles!invoices_paid_by_fkey (email),
			voided_by_user:profiles!invoices_voided_by_fkey (email)
		`)
		.eq('org_id', org_id)
		.order('updated_at', { ascending: false })
		.limit(limit) as { data: InvoiceAuditRow[] | null; error: any };

	if (invoicesError) {
		console.error('Error fetching audit log:', invoicesError);
		return [];
	}

	// Transform into audit events
	const events: Array<{
		type: string;
		description: string;
		actor_email: string;
		target_email: string;
		timestamp: string;
		invoice_number: string;
		amount: number;
	}> = [];

	for (const inv of recentInvoices || []) {
		// Created event
		events.push({
			type: 'invoice_created',
			description: `Created invoice ${inv.invoice_number}`,
			actor_email: (inv.created_by_user as any)?.email || 'System',
			target_email: (inv.user as any)?.email || 'Unknown',
			timestamp: inv.created_at,
			invoice_number: inv.invoice_number,
			amount: inv.total_amount
		});

		// Paid event
		if (inv.paid_at) {
			events.push({
				type: 'invoice_paid',
				description: `Marked invoice ${inv.invoice_number} as paid`,
				actor_email: (inv.paid_by_user as any)?.email || 'System',
				target_email: (inv.user as any)?.email || 'Unknown',
				timestamp: inv.paid_at,
				invoice_number: inv.invoice_number,
				amount: inv.total_amount
			});
		}

		// Voided event
		if (inv.voided_at) {
			events.push({
				type: 'invoice_voided',
				description: `Voided invoice ${inv.invoice_number}`,
				actor_email: (inv.voided_by_user as any)?.email || 'System',
				target_email: (inv.user as any)?.email || 'Unknown',
				timestamp: inv.voided_at,
				invoice_number: inv.invoice_number,
				amount: inv.total_amount
			});
		}
	}

	// Sort by timestamp descending
	events.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

	return events.slice(0, limit);
});
